
 Book   : Professional JavaScript for Web Developers
 Author : Nicholas Zakas
 Year   : 2012

                               TABLE OF CONTENTS
                               =================

 CHAP  1: JAVASCRIPT HISTORY
 CHAP  3: LANGUAGE BASICS
 CHAP  4: VARIABLES, SCOPE, AND MEMORY
 CHAP  5: REFERENCE TYPES
 CHAP  6: OBJECT-ORIENTED PROGRAMMING
 CHAP  7: FUNCTION EXPRESSION
 CHAP  8: THE BROWSER OBJECT MODEL
 CHAP 10: THE DOCUMENT OBJECT MODEL (DOM Level 1)
 CHAP 13: EVENTS
 CHAP 14: SCRIPTING FORMS
 CHAP 17: ERROR HANDLER AND DEBUGGING
 CHAP 20: JSON
 CHAP 21: AJAX

 APPENDIX
 TOOLS


================================================================================

                           CHAP  1: JAVASCRIPT HISTORY
                           --------------------------

    1. Short History
    2. JavaScript Implementations
    3. Summary


    When JavaScript first appeared in 1995, its main purpose was to handle some
    of the input validation that had previously been left to server-side
    languages such as Perl.

    Since that time, JavaScript has grown into an important feature of every
    major web browser on the market. No longer bound to simple data validation,
    JavaScript now interacts with nearly all aspects of the browser window and
    its contents.

    1. Short History
    ----------------

    Brendan Eich, who worked for Netscape at the time, began developing a
    scripting language called Mocha, and later LiveScript, for the release of
    Netscape Navigator 2 in 1995, with the intention of using it both in the
    browser and on the server (where it was to be called LiveWire). Netscape
    entered into a development alliance with Sun Microsystems to complete the
    implementation of LiveScript in time for release. Just before Netscape
    Navigator 2 was officially released, Netscape changed LiveScript's name to
    JavaScript to capitalize on the buzz that Java was receiving from the press.

    2. JavaScript Implementations
    -----------------------------

    JavaScript implementation is made up of the following three distinct parts:

    ** The Core (ECMAScript) **
    ** The Document Object Model (DOM) **
    ** The Browser Object Model (BOM) **


    ** The Core (ECMAScript) **

    ECMAScript, the language defined in ECMA-262, isn't tied to web browsers.
    ECMA-262 defines this language as a base upon which more-robust scripting
    languages may be built. Web browsers are just one host environment in which
    an ECMAScript implementation may exist. A host environment provides the base
    implementation of ECMAScript and implementation extensions designed to
    interface with the environment itself.

    Extensions, such as the Document Object Model (DOM), use ECMAScript's
    core types and syntax to provide additional functionality that's more
    specific to the environment.  Other host environments include NodeJS, a
    server-side JavaScript platform, and Adobe Flash.

    ECMAScript is simply a description of a language implementing all of the
    facets described in the specification. JavaScript implements ECMAScript,
    but so does Adobe ActionScript.


    ** The Document Object Model (DOM) **

    The Document Object Model (DOM) is an application programming interface
    (API) for XML that was extended for use in HTML. The DOM maps out an entire
    page as a hierarchy of nodes. Each part of an HTML or XML page is a type of
    a node containing different kinds of data. Nodes can be removed, added,
    replaced, and modified easily by using the DOM API.

    DOM Levels

    DOM Level 1 became a W3C recommendation in October 1998. It consisted of two
    modules: the DOM Core, which provided a way to map the structure of an XML-
    based document to allow for easy access to and manipulation of any part of a
    document, and the DOM HTML, which extended the DOM Core by adding
    HTML-specific objects and methods.

    NOTE: Note that the DOM is not JavaScript-specific and indeed has been
          implemented in numerous other languages. For web browsers, however,
          the DOM has been implemented using ECMAScript and now makes up a large
          part of the JavaScript language.

    Whereas the goal of DOM Level 1 was to map out the structure of a document,
    the aims of DOM Level 2 were much broader. DOM Level 2 introduced the
    following new modules of the DOM to deal with new types of
    interfaces:

    DOM Views - Describes interfaces to keep track of the various views of a
                document (ie. the document before and after CSS styling)
    DOM Event - Describes interfaces for events and event handling
    DOM Style - Describes interfaces to deal with CSS-based styling of elements
    DOM Traversal and Range - Describes interfaces to traverse and manipulate a
                              document tree

    DOM Level 3 further extends the DOM with the introduction of methods to load
    and save documents in a uniform way (contained in a new module called DOM
    Load and Save) and methods to validate a document (DOM Validation).


    ** The Browser Object Model (BOM) **

    Using the BOM, developers can interact with the browser outside of the
    context of its displayed page.  What made the BOM truly unique, and often
    problematic, was that it was the only part of a JavaScript implementation
    that had no related standard. This changed with the introduction of HTML5,
    which sought to codify much of the BOM as part of a formal specification.
    Thanks to HTML5, a lot of the confusion surrounding the BOM has dissipated.

    Primarily, the BOM deals with the browser window and frames, but generally
    any browser-specific extension to JavaScript is considered to be a part of
    the BOM. The following are some such extension:

        - The capability to pop up new browser windows
        - The capability to move, resize, and close browser windows
        - The navigator object, which provides detailed information about the
          browser
        - The location object, which gives detailed information about the page
          loaded in the browser
        - The screen object, which gives detailed information about the user's
          screen resolution
        - Support for cookies

    Because no standards existed for the BOM for a long time, each browser has
    its own implementation. There are some de facto standards, such as having a
    window object and a navigator object. With HTML5 now available, the
    implementation details of the BOM are expected to grow in a much more
    compatible way.


    3. Summary
    ----------

    JavaScript is a scripting language designed to interact with web pages and
    is made up of the following three distinct parts:

        - ECMAScript, which is defined in ECMA-262 and provides the core
          functionality.
        - The Document Object Model (DOM), which provides methods and interfaces
          for working with the content of a web page.
        - The Browser Object Model (BOM), which provides methods and interfaces for
          interacting with the browser.

    Support for ECMAScript 3 is generally good across all browsers, and support
    for ECMAScript 5 is growing, whereas support for the DOM varies widely. The
    BOM, recently codified in HTML5, can vary from browser to browser, though
    there are some commonalities that are assumed to be available.

================================================================================


                            CHAP  3: LANGUAGE BASICS
                            ------------------------

 1. Reviewing syntax
 2. Working with data types
 3. Working with flow-control statements
 4. Understanding functions


 1. Reviewing syntax
 -------------------

    ECMAScript's syntax borrows heavily from C and other C-like languages such
    as Java and Perl.

    An identifier is the name of a variable, function, property, or function
    argument. Identifiers may be one or more characters in the following format:

        - The first character must be a letter, an underscore (_), or a dollar
          sign ($).
        - All other characters may be letters, underscores, dollar signs, or
          numbers.


    ECMAScript uses C-style comments for both single-line and block comments. A
    single-line comment begins with two forward-slash characters, such as this:

        // single line comment

    A block comment begins with a forward slash and asterisk (/*) and ends with
    the opposite (*/),

        /*
         * This is multi-line
         * comment
         */


    ECMAScript 5 introduced the concept of strict mode. Strict mode is a
    different parsing and execution model for JavaScript, where some of the
    erratic behavior of ECMAScript 3 is addressed and errors are thrown for
    unsafe activities. To enable strict mode for an entire script, include the
    following at the top:

        "use strict";

    This is a pragma that tells supporting JavaScript engines to change into
    strict mode. The syntax was chosen specifi cally so as not to break
    ECMAScript 3 syntax.  You may also specify just a function to execute in
    strict mode by including the pragma at the top of the function body:

        function doSomething() {
            "use strict";
            ...
        }


    Statements in ECMAScript are terminated by a semicolon, though omitting the
    semicolon makes the parser determine where the end of a statement occurs.

    Even though a semicolon is not required at the end of statements, it is
    recommended to always include one. Including semicolons helps prevent errors
    of omission, such as not finishing what you were typing, and allows
    developers to compress ECMAScript code by removing extra white space.

    ECMA-262 describes a set of keywords that have specific uses, such as
    indicating the beginning or end of control statements or performing specific
    operations. By rule, keywords are reserved and cannot be used as identifiers
    or property names.

    ECMAScript variables are loosely typed, meaning that a variable can hold any
    type of data. Every variable is simply a named placeholder for a value. To
    define a variable, use the var operator (note that var is a keyword)
    followed by the variable name.

    It's important to note that using the 'var' operator to define a variable
    makes it local to the scope in which it was defined. For example, defining
    a variable inside of a function using var means that the variable is
    destroyed as soon as the function exits.

    Ex.
        var message;

    This code defines a variable named message that can be used to hold any
    value. (Without initialization, it holds the special value undefined).
    Though it's not recommended to switch the data type that a variable
    contains, it is completely valid in ECMAScript.

    By removing the var operator from the example, the message variable becomes
    global. As soon as the function test() is called, the variable is defined
    and becomes accessible outside of the function once it has been executed.



 2. Working with data types
 --------------------------

    There are five simple data types (also called primitive types) in
    ECMAScript:

    ** Undefined Type **
    ** Null Type **
    ** Boolean Type **
    ** Number Type **
    ** String Type **

    ** Object Type **

    There is also one complex data type called Object, which is an unordered
    list of name-value pairs. Because there is no way to define your own data
    types in ECMAScript, all values can be represented as one of these six.

    Because ECMAScript is loosely typed, there needs to be a way to determine
    the data type of a given variable. The typeof operator provides that
    information. Using the typeof operator on a value returns one of the
    following strings:

        "undefined" if the value is undefined
        "boolean" if the value is a Boolean
        "string" if the value is a string
        "number" if the value is a number
        "object" if the value is an object (other than a function) or null
        "function" if the value is a function

    Ex.
        var message = "some string";
        alert(typeof message);

    Note that because typeof is an operator and not a function, no parentheses
    are required (although they can be used). Be aware there are a few cases
    where typeof seemingly returns a confusing but technically correct value.
    Calling typeof null returns a value of "object", as the special value null
    is considered to be an empty object reference.

    NOTE: Technically, functions are considered objects in ECMAScript and don't
          represent another data type. However, they do have some special
          properties, which necessitates differentiating between functions and
          other objects via the typeof operator.


    ** Undefined Type **
    --------------------

    The Undefined type has only one value, which is the special value undefined.
    When a variable is declared using var but not initialized, it is assigned
    the value of undefined as follows:

    Ex.
        var message;
        alert(message == undefined); //true


    Note that a variable containing the value of undefined is different from a
    variable that hasn't been defined at all.

    NOTE: Even though uninitialized variables are automatically assigned a value
          of undefined, it is advisable to always initialize variables. That
          way, when typeof returns "undefined", you'll know that it's because a
          given variable hasn't been declared rather than was simply not
          initialized.


    ** Null Type **
    ---------------

    The Null type is the second data type that has only one value: the special
    value null. Logically, a null value is an empty object pointer, which is why
    typeof returns "object" when it's passed a null value:

        var car = null;
        alert(typeof car); //"object"

    When defining a variable that is meant to later hold an object, it is
    advisable to initialize the variable to null as opposed to anything else.
    That way, you can explicitly check for the value null to determine if the
    variable has been filled with an object reference at a later time,

    The value undefined is a derivative of null, so ECMA-262 defines them to be
    superfi cially equal as follows:

        alert(null == undefined); // true

    Even though null and undefined are related, they have very different uses.
    You should never explicitly set the value of a variable to undefined, but
    the same does not hold true for null. Any time an object is expected but is
    not available, null should be used in its place. This helps to keep the
    paradigm of null as an empty object pointer and further differentiates it
    from undefined.


    ** Boolean Type **
    ------------------

    The Boolean type is one of the most frequently used types in ECMAScript and
    has only two literal values: true and false. These values are distinct
    from numeric values, so true is not equal to 1, and false is not equal to 0.


    ** Number Type **
    -----------------

    NaN

    There is a special numeric value called NaN, short for Not a Number, which
    is used to indicate when an operation intended to return a number has failed
    (as opposed to throwing an error). For example, dividing any number by 0
    typically causes an error in other programming languages, halting code
    execution. In ECMAScript, dividing a number by 0 returns NaN, which allows
    other processing to continue.


    ** String Type **
    -----------------

    Strings can be delineated by either double quotes (") or single quotes (').
    Unlike PHP, for which using double or single quotes changes how the string
    is interpreted, there is no difference in the two syntaxes in ECMAScript. A
    string using double quotes is exactly the same as a string using single
    quotes. Note, however, that a string beginning with a double quote must end
    with a double quote, and a string beginning with a single quote must end
    with a single quote.

    Strings are immutable in ECMAScript, meaning that once they are created,
    their values cannot change. To change the string held by a variable, the
    original string must be destroyed and the variable filled with another
    string containing a new value.

    There are two ways to convert a value into a string. The first is to use
    the toString() method that almost every value has.

        var age = 11;
        var ageString = age.toString();

    If you're not sure that a value isn't null or undefined, you can use the
    String() casting function, which always returns a string regardless of the
    value type.

        var value1 = 10
        var value2 = true;

        alert(String(value1));
        alert(String(value2));

    NOTE: You can also convert a value to a string by adding an empty string
          ("") to that value using the plus operator.


    ** Object Type **
    -----------------

    Objects in ECMAScript start out as nonspecific groups of data and
    functionality. Objects are created by using the new operator followed by the
    name of the object type to create. Developers create their own objects by
    creating instances of the Object type and adding properties and/or methods
    to it, as shown here:

        var obj = new Object();

    ECMAScript requires parentheses to be used only when providing arguments to
    the constructor. If there are no arguments, then the parentheses can be
    omitted safely (though that's not recommended):

    Ex.

        var o = new Object; //legal, but not recommended

    The Object type in ECMAScript is the base from which all other objects are
    derived. All of the properties and methods of the Object type are also
    present on other, more specific objects.

    Each Object instance has the following properties and methods:

    > constructor - The function that was used to create the object. In the
                    previous example, the constructor is the Object() function.

    > hasOwnProperty(propertyName) - Indicates if the given property exists on
                    the object instance (not on the prototype). The property
                    name must be specified as a string (for example,
                    o.hasOwnProperty("name")).

    > isPrototypeOf(object) - Determines if the object is a prototype of another
                    object.
    > propertyIsEnumerable(propertyName) - Indicates if the given property can
                    be enumerated using the for-in statement.  As with
                    hasOwnProperty(), the property name must be a string.

    > toLocaleString() - Returns a string representation of the object that is
                    appropriate for the locale of execution environment.

    > toString() - Returns a string representation of the object.

    > valueOf() - Returns a string, number, or Boolean equivalent of the object.
                    It often returns the same value as toString().


    Since "Object" is the base for all objects in ECMAScript, every object has
    these base properties and methods.

    NOTE: Technically speaking, the behavior of objects need not necessarily
          apply to other objects in JavaScript. Objects that exist in the
          browser environment, such as those in the BOM and DOM, are considered
          host objects since they are provided and defined by the host
          implementation. Host objects aren't governed by ECMA-262 and, as such,
          may or may not directly inherit from "Object".



 3. Working with flow-control statements
 ---------------------------------------

    ECMA-262 describes several statements (also called flow-control statements).
    Essentially, statements define most of the syntax of ECMAScript and
    typically use one or more keywords to accomplish a given task.

    ** The for-in Statements **
    ** Labeled Statements **
    ** The with Statements **


    ** The for-in Statements **

    The for-in statement is a strict iterative statement. It is used to
    enumerate the properties of an object.

    Ex.

        for (var propName in window) {
            document.write(propName);
        }

    Here, the for-in statement is used to display all the properties of the BOM
    window object. Each time through the loop, the propName variable is filled
    with the name of a property that exists on the window object. This continues
    until all of the available properties have been enumerated over. As with the
    for statement, the var operator in the control statement is not necessary
    but is recommended for ensuring the use of a local variable.

    Object properties in ECMAScript are unordered, so the order in which
    property names are returned in a for-in statement cannot necessarily be
    predicted. All enumerable properties will be returned once, but the order
    may differ across browsers.

    Note that the for-in statement will throw an error if the variable
    representing the object to iterate over is null or undefined. ECMAScript 5
    updates this behavior to not throw an error and simply doesn't execute the
    body of the loop. For best cross-browser compatibility, it's recommended to
    check that the object value isn't null or undefined before attempting to use
    a for-in loop.


    ** Labeled Statements **

    ** The with Statements **

    In strict mode, the "with" statement is not allowed and is considered a
    syntax error.

    It is widely considered a poor practice to use the with statement in
    production code because of its negative performance impact and the
    difficulty in debugging code contained in the with statement.



 4. Understanding functions
 --------------------------

    ** Understanding Arguments **
    ** No Overloading **


    Functions are the core of any language, because they allow the encapsulation
    of statements that can be run anywhere and at any time. Functions in
    ECMAScript are declared using the function keyword, followed by a set of
    arguments and then the body of the function.

    Functions in ECMAScript need not specify whether they return a value. Any
    function can return a value at any time by using the "return" statement
    followed by the value to return.


    ** Understanding Arguments **
    -----------------------------

    Function arguments in ECMAScript don't behave in the same way as function
    arguments in most other languages. An ECMAScript function doesn't care how
    many arguments are passed in, nor does it care about the data types of those
    arguments. Just because you define a function to accept two arguments
    doesn't mean you can pass in only two arguments. You could pass in one or three
    or none, and the interpreter won't complain. This happens because arguments
    in ECMAScript are represented as an array internally. The array is always
    passed to the function, but the function doesn't care what (if anything) is
    in the array.  In fact, there actually is an "arguments" object that can be
    accessed while inside a function to retrieve the values of each argument
    that was passed in.

    The "arguments" object acts like an array (though it isn't an instance of
    Array) in that you can access each argument using bracket notation (the
    first argument is arguments[0], the second is arguments[1], and so on) and
    determine how many arguments were passed in by using the length property.

    This illustrates an important point about functions in ECMAScript: named
    arguments are a convenience, not a necessity. Unlike in other languages,
    naming your arguments in ECMAScript does not create a function signature
    that must be match later on; there is no validation against named arguments.

        function func1() {
            alert('arg1: ' + arguments[0] + ', arg2: ' + arguments[1]);
        }

    The arguments object can also be used to check the number of arguments
    passed into the function via the length property. The following example
    outputs the number of arguments passed into the function each time it is
    called:

        function func1() {
            alert(arguments.length);
        }

    Another thing to keep in mind: if only one argument is passed in, then
    setting arguments[1] to a value will not be reflected by the named argument.
    This is because the length of the arguments object is set based on the
    number of arguments passed in, not the number of named arguments listed for
    the function.

    Any named argument that is not passed into the function is automatically
    assigned the value undefined. This is akin to defining a variable without
    initializing it. For example, if only one argument is passed into the
    doAdd() function, then num2 has a value of undefined.

    NOTE: All arguments in ECMAScript are passed by value. It is not possible to
          pass arguments by reference.


    ** No Overloading **
    --------------------

    ECMAScript functions cannot be overloaded in the traditional sense. In other
    languages, such as Java, it is possible to write two definitions of a
    function so long as their signatures (the type and number of arguments
    accepted) are different.



================================================================================


                      CHAP  4: VARIABLES, SCOPE, AND MEMORY
                      ------------------------------------


    1. Working with primitive and reference values in variables
    2. Understanding execution context
    3. Understanding garbage collection


    The nature of variables in JavaScript, as defined in ECMA-262, is quite
    unique compared to that of other languages. Being loosely typed, a variable
    is literally just a name for a particular value at a particular time.
    Because there are no rules defining the type of data that a variable must
    hold, a variable's value and data type can change during the lifetime of a
    script. Though this is an interesting, powerful, and problematic feature,
    there are many more complexities related to variables.


    1. Working with primitive and reference values in variables
    -----------------------------------------------------------

    ** Dynamic Properties **
    ** Copying Values **
    ** Argument Passing **

    ECMAScript variables may contain two different types of data: primitive
    values and reference values. Primitive values are simple atomic pieces of
    data, while reference values are objects that may be made up of multiple
    values.

    When a value is assigned to a variable, the JavaScript engine must determine
    if it's a primitive or a reference. For five primitive types, these
    variables are said to be accessed by value, because you are manipulating the
    actual value stored in the variable.

    Primitive types: Undefined, Null, Boolean, Number, and String.

    Reference values are objects stored in memory. Unlike other languages,
    JavaScript does not permit direct access of memory locations, so direct
    manipulation of the object's memory space is not allowed. When you manipulate
    an object, you're really working on a reference to that object rather than
    the actual object itself. For this reason, such values are said to be
    accessed by reference.


    ** Dynamic Properties **
    ------------------------

    Primitive and reference values are defined similarly: a variable is created
    and assigned a value. What you can do with those values once they're stored
    in a variable, however, is quite different. When you work with reference
    values, you can add, change, or delete properties and methods at any time.

        var person  = new Object();
        person.name = "Nicholas";
        alert(person.name);             // Nicholas

    Here, an object is created and stored in the variable person.  The new
    property is then accessible from that point on, until the object is destroyed
    or the property is explicitly removed.

    Primitive values can't have properties added to them even though attempting
    to do so won't cause an error

        var name = "Nicholas";
        name.age = 27;
        alert(name.age);   //undefined

    Only reference values can have properties defined dynamically for later use.


    ** Copying Values **
    --------------------

    Aside from differences in how they are stored, primitive and reference
    values act differently when copied from one variable to another. When a
    primitive value is assigned from one variable to another, the value stored
    on the variable object is created and copied into the location for the new
    variable.

        var num1 = 5;
        var num2 = num1;

    Here, num1 contains the value of 5. When num2 is initialized to num1, it
    also gets the value of 5. This value is completely separate from the one
    that is stored in num1, because it's a copy of that value.

    When a reference value is assigned from one variable to another, the value
    stored on the variable object is also copied into the location for the new
    variable. The difference is that this value is actually a pointer to an
    object stored on the heap. Once the operation is complete, two variables
    point to exactly the same object, so changes to one are reflected on the
    other.

        var obj1 = new Object();
        var obj2 = obj1;
        obj1.name = "Nicholas";
        alert(obj2.name);       //Nicholas

    In this example, the variable obj1 is filled with a new instance of an
    object. This value is then copied into obj2, meaning that both variables are
    now pointing to the same object. When the property name is set on obj1, it
    can later be accessed from obj2 because they both point to the same object.


    ** Argument Passing **
    ----------------------

    All function arguments in ECMAScript are passed by value. This means that
    the value outside of the function is copied into an argument on the inside
    of the function the same way a value is copied from one variable to another.
    If the value is primitive, then it acts just like a primitive variable copy,
    and if the value is a reference, it acts just like a reference variable copy.
    This is often a point of confusion for developers, because variables are
    accessed both by value and by reference, but arguments are passed only by
    value.

    When an argument is passed by value, the value is copied into a local
    variable (a named argument and, in ECMAScript, a slot in the arguments
    object). When an argument is passed by reference, the location of the value
    in memory is stored into a local variable, which means that changes to the
    local variable are reflected outside of the function.

        function addTen(num) {
            num += 10;
            return num;
        }

        var count = 20;
        var result = addTen(count);
        alert(count);               // 20 - no change
        alert(result);              // 30



    2. Understanding execution context
    ----------------------------------

    ** Scope Chain Augmentation **
    ** No Block-Level Scopes **

    The concept of execution context, referred to as context for simplicity, is
    of the utmost importance in JavaScript. The execution context of a variable
    or function defines what other data it has access to, as well as how it
    should behave. Each execution context has an associated variable object upon
    which all of its defined variables and functions exist. This object is not
    accessible by code but is used behind the scenes to handle data.

    The global execution context is the outermost one. Depending on the host
    environment for an ECMAScript implementation, the object representing this
    context may differ.  In web browsers, the global context is said to be that
    of the "window" object.

    Each function call has its own execution context. Whenever code execution
    flows into a function, the function's context is pushed onto a context stack.
    After the function has finished executing, the stack is popped, returning
    control to the previously executing context. This facility controls
    execution flow throughout an ECMAScript program.

    When code is executed in a context, a scope chain of variable objects is
    created. The purpose of the scope chain is to provide ordered access to all
    variables and functions that an execution context has access to. The front
    of the scope chain is always the variable object of the context whose code is
    executing. If the context is a function, then the activation object is used
    as the variable object. An activation object starts with a single defined
    variable called arguments.  (This doesn't exist for the global context.)
    The next variable object in the chain is from the containing context, and
    the next after that is from the next containing context. This pattern
    continues until the global context is reached; the global context's variable
    object is always the last of the scope chain.

    Identifiers are resolved by navigating the scope chain in search of the
    identifier name. The search always begins at the front of the chain and
    proceeds to the back until the identifier is found. (If the identifier isn't
    found, typically an error occurs.)


    ** Scope Chain Augmentation **
    ------------------------------

    Even though there are only two primary types of execution contexts, global
    and function (the third exists inside of a call to eval()), there are other
    ways to augment the scope chain. Certain statements cause a temporary
    addition to the front of the scope chain that is later removed after
    code execution. There are two times when this occurs, specifically when
    execution enters either of the following:
        - The catch block in a try-catch statement
        - A with statement



    ** No Block-Level Scopes **
    ---------------------------

    JavaScript's lack of block-level scopes is a common source of confusion. In
    other C-like languages, code blocks enclosed by brackets have their own
    scope (more accurately described as their own execution context in
    ECMAScript), allowing conditional definition of variables.

        for (var i=0; i < 10; i++) {
            doSomething(i);
        }

    In languages with block-level scoping, the initialization part of the "for"
    statement defines variables that exist only within the context of the loop.
    In JavaScript, the "i" variable is created by the for statement and
    continues to exist outside the loop after the statement executes.

    When a variable is declared using var, it is automatically added to the most
    immediate context available. In a function, the most immediate one is the
    function's local context. If a variable is initialized without first being
    declared, it gets added to the global context automatically.

    NOTE: Initializing variables without declaring them is a very common mistake
          in JavaScript programming and can lead to errors. It's advisable to
          always declare variables before initializing them to avoid such
          issues. In strict mode, initializing variables without declaration
          causes an error.


    3. Understanding garbage collection
    -----------------------------------

    JavaScript is a garbage-collected language, meaning that the execution
    environment is responsible for managing the memory required during code
    execution.  JavaScript frees developers from worrying about memory
    management by automatically allocating what is needed and reclaiming memory
    that is no longer being used. The basic idea is simple: figure out which
    variables aren't going to be used and free the memory associated with them.
    This process is periodic, with the garbage collector running at specified
    intervals (or at predefined collection moments in code execution).

    Consider the normal life cycle of a local variable in a function. The
    variable comes into existence during the execution of the function. At that
    time, memory is allocated on the stack (and possibly on the heap) to provide
    storage space for the value. The variable is used inside the function and
    then the function ends. At that point this variable is no longer needed, so
    its memory can be reclaimed for later use.


================================================================================


                            CHAP  5: REFERENCE TYPES
                            ------------------------

    1. Working with objects
    2. Creating and manipulating arrays
    3. Understanding basic JavaScript Date types
    4. The Function Type
    5. Working with primitives and primitive wrappers
    6. Singleton Built-in Objects
    7. Summary


    A reference value (object) is an instance of a specific reference type. In
    ECMAScript, reference types are structures used to group data and
    functionality together and are often incorrectly called classes. Although
    technically an object-oriented language, ECMAScript lacks some basic
    constructs that have traditionally been associated with object-oriented
    programming, including classes and interfaces. Reference types are also
    sometimes called object definitions, because they describe the properties
    and methods that objects should have.

    NOTE: Even though reference types are similar to classes, the two concepts
          are not equivalent.


    Again, objects are considered to be instances of a particular reference
    type. New objects are created by using the "new" operator followed by
    constructor. A constructor is simply a function whose purpose is to create a
    new object.

        var person = new Object();

    The constructor being used is Object(), which creates a simple object with
    only the default properties and methods. ECMAScript provides a number of
    native reference types, such as Object, to help developers with common
    computing tasks.


    1. Working with objects
    -----------------------

    ** The Object Type **
    ** The Date Type **
    ** The RegExp Type **
    ** The Function Type **
    ** Primitive Wrapper Types **


    Up to this point, most of the reference-value examples have used "Object"
    type, which is one of the most often-used types in ECMAScript. Although
    instances of Object don't have much functionality, they are ideally suited
    to storing and transmitting data around an application.

    There are two ways to explicitly create an instance of Object. The first is
    to use the "new" operator with the Object constructor like this:

    Ex.

        var person  = new Object();
        person.name = "Nicholas"
        person.age  = 29;

    The other way is to use object literal notation. Object literal notation is
    a shorthand form of object definition designed to simplify creating an
    object with numerous properties.

    Ex.

        var person = {
            name : "Nicholas",
            age  : 29
        };

    In this example, the left curly brace ({) signifies the beginning of an
    object literal, because it occurs in an expression context. An expression
    context in ECMAScript is a context in which value (expression) is expected.

    Property names can also be specified as strings or numbers when using
    object literal notation:

        var person = {
            "name" : "Nicholas",
            "age"  : 29,
            5      : true
        };

    It's also possible to create an object with only the default properties and
    methods using object literal notation by leaving the space between the curly
    braces empty,

        var person = {}     // same as new Object()
        person.name = "Nicholas";
        person.age  = 29;

    NOTE: When defining an object via object literal notation, the Object
          constructor is never actually called.

    Developers tend to favor object literal notation, because it requires less
    code and visually encapsulates all related data. In fact, object literals
    have become a preferred way of passing a large number of optional arguments
    to a function.

    Ex.

        function displayInfo(args) {
            var output = '';

            if (typeof args.name == 'string') {
                output += 'Name: ' + args.name + '\n';
            }

            if (typeof args.age == 'number' {
                output += 'Age: ' + args.age + '\n';
            }

            alert(output);
        }

        displayInfo({
            name: "Nicholas",
            age : 29
        });

        displayInfo({
            name: "Greg"
        });


    Here, the function displayInfo() accepts a single argument named args. The
    argument may come in with a property called name or age or both or neither
    of those.

    NOTE: This pattern for argument passing is best used when there is a large
          number of optional arguments that can be passed into the function.
          Generally speaking, named arguments are easier to work with but can get
          unwieldy when there are numerous optional arguments. The best approach
          is to use named arguments for those that are required and an object
          literal to encompass multiple optional arguments.


    Although object properties are typically accessed using dot notation, which
    is common to many object-oriented languages, it's also possible to access
    properties via bracket notation.

        alert(person['name']);
        alert(person.name);


    2. Creating and manipulating arrays
    -----------------------------------

    ** Detecting Arrays **
    ** Conversion Methods **
    ** Stack Methods **
    ** Queue Methods **
    ** Reordering Methods **
    ** Manipulation Methods **
    ** Location Methods **
    ** Iterative Methods **
    ** Reduction Methods **

    After the Object type, the Array type is probably the most used in
    ECMAScript. An ECMAScript array is very different from arrays in most other
    programming languages. As in other languages, ECMAScript arrays are ordered
    lists of data, but unlike in other languages, they can hold any type of data
    in each slot. This means that it's possible to create an array that has
    string in the first position, a number in the second, an object in the third
    and so on.  ECMAScript arrays are also dynamically sized, automatically
    growing to accommodate any data that is added to them.  Arrays can be
    created in two basic ways.

        var colors = new Array();

    The Array constructor can also be passed items that should be included in
    the array. The following creates an array with three string values:

        var colors = new Array('red', 'blue', 'green');

    It's possible to omit the new operator when using the Array constructor.

        var colors = Array(3);

    The second way to create an array is by using array literal notation. An
    array literal is specified by using square brackets and placing a
    comma-separated list of items between them,

        var colors = ['red', 'blue', 'green'];

    NOTE: As with objects, the Array constructor isn't called when an array is
          created using array literal notation.

    To get and set array values, you use square brackets and provide the
    zero-based numeric index of the value,

        var colors = ['red', 'blue', 'green'];
        alert(colors[0]);
        colors[2] = 'black';

    The number of items in an array is stored in the "length" property:

        alert(colors.length);


    ** Detecting Arrays **

    When dealing with a single web page, and therefore a single
    global scope, the instanceof operator works well:

        if (value instanceof Array) {
            ...
        }

    ECMAScript 5 introduced the Array.isArray() method. The purpose of this
    method is to definitively determine if a given value is an array regardless
    of the global execution context in which it was created:

        if (Array.isArray(value) {
            ...
        }


    ** Conversion Methods **

    All objects have toLocaleString(), toString(), and valueOf() methods. The
    toString() and valueOf() methods return the same value when called on an
    array.  The result is a comma-separated string that contains the string
    equivalents of each value in the array.

        alerts(colors.toString());
        alerts(colors.valueOf());


    ** Stack Methods **

    One of the interesting things about ECMAScript arrays is that they provide a
    method to make an array behave like other data structures. An array object
    can act just like a stack, which is one of a group of data structures that
    restrict the insertion and removal of items. A stack is referred to as a
    last-in-first-out (LIFO) structure, meaning that the most recently added
    item is the first one removed. The insertion (called a push) and removal
    (called a pop) of items in a stack occur at only one point: the top of the
    stack. ECMAScript arrays provide push() and pop() specifically to allow
    stack-like behavior.

        var colors = new Array();
        var count = colors.push('red', 'green');
        alert(count); //2

        var item = colors.pop()
        alert(item); //green


    ** Queue Methods **

    Just as stacks restrict access in a LIFO data structure, queues restrict
    access in a first-in-first-out (FIFO) data structure. A queue adds items to
    the end of a list and retrieves items from the front of the list. The array
    method for this is called shift(), which removes the first item in the
    array and returns it, decrementing the length of the array by one.

    Ex.

        var colors = new Array();
        var count = colors.push('red', 'green');

        var item = colors.shift();
        alert(item) //red

    ECMAScript also provides an unshift() method for arrays. As the name
    indicates, unshift() does the opposite of shift(): it adds any number of
    items to the front of an array and returns the new array length.


    ** Reordering Methods **

        var values = [1, 2, 3, 4, 5];
        values.reverse();

    ** Manipulation Methods **

    The concat() method allows you to create a new array based on all of the
    items in the current array.

        var colors = ['red', 'green', 'blue'];
        var colors2 = colors.concat('yellow', ['black', 'brown']);
        alert(colors);                  //red,green,blue
        alert(colors2);                 //red,green,blue,yellow,black,brown

    Perhaps the most powerful array method is splice(), purpose of splice() is
    to insert items into the middle of an array, but there are three distinct
    ways of using this method.

    ** Location Methods **

    ECMAScript 5 adds two item location methods to array instances: indexOf()
    and lastIndexOf().


    ** Iterative Methods **

    ECMAScript 5 defines five iterative methods for arrays. Each of the methods
    accepts two arguments: a function to run on each item and an optional scope
    object in which to run the function (affecting the value of 'this'). The
    function passed into one of these methods will receive three arguments: the
    array item value, the position of the item in the array, and the array
    object itself. Depending on the method, the results of this function's
    execution may or may not affect the method's return value.

        every() - Runs the given function on every item in the array and returns
                  true if the function returns true for every item.
       filter() - Runs the given function on every item in the array and
                  returns an array of all items for which the function returns
                  true.
      forEach() - Runs the given function on every item in the array. This
                  method has no return value.
          map() - Runs the given function on every item in the array and returns
                  the result of each function call in an array.
         some() - Runs the given function on every item in the array and returns
                  true if the function returns true for any one item.

    These methods do not change the values contained in the array.

    Ex.

        var numbers = [1,2,3,4,5,4,3,2,1];

        var everyResult = numbers.every(function(item, index, array) {
                return (item > 2);
        });

        alert(everyResult);     // false

        var someResult = numbers.every(function(item, index, array) {
                return (item > 2);
        });

        alert(someResult);      // true


    Ex.

        var numbers = [1,2,3,4,5,4,3,2,1];

        var filterResult = numbers.filter(function(item, index, array) {
            return (item > 2);
        });

        alert(filterResult);    // [3,4,5,4,3]


    The map() method also returns an array. Each item in the array is the result
    of running the passedin function on the original array item in the same
    location. For example, you can multiply every number in an array by two and
    are returned an array of those numbers.

    Ex.

        var numbers = [1,2,3,4,5,4,3,2,1];

        var mapResult = numbers.map(function(item, index, array) {
            return item * 2;
        });

        alert(mapResult);       // [2,4,6,8,10,8,6,4,2]

    The last method is forEach(), which simply runs the given function on every
    item in an array. There is no return value and is essentially the same as
    iterating over an array using a for loop.


    ** Reduction Methods **

    ECMAScript 5 also introduced two reduction methods for arrays: reduce() and
    reduceRight().  Both methods iterate over all items in the array and build
    up a value that is ultimately returned.  The reduce() method does this
    starting at the first item and traveling toward the last, whereas
    reduceRight() starts at the last and travels toward the first.


    3. Understanding basic JavaScript Date types
    -------------------------------------------

    ** Inherited Methods **
    ** Date-Formatting Methods **
    ** Date/Time Component Methods **

    The Date type stores dates as the number of milliseconds that have passed
    since midnight on January 1, 1970 UTC (Universal Time Code). Using this data
    storage format, the Date type can accurately represent dates 285,616 years
    before or after January 1, 1970.

        var now = new Date();

    When the Date constructor is used without any arguments, the created object
    is assigned the current date and time. To aid in this process, ECMAScript
    provides two methods: Date.parse() and Date.UTC().

    Ex.

        var someDate = new Date(Date.parse("May 25, 2004"));
            -or-
        var someDate = new Date("May 26, 2004");

        //January 1, 2000 at midnight GMT
        var y2k = new Date(Date.UTC(2000, 0));

        //May 5, 2005 at 5:55:55 PM GMT
        var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));

    ** Inherited Methods **
    ** Date-Formatting Methods **

        toDateString() - Displays the date.s day of the week, month, day of the
                         month, and year

        toTimeString() - Displays the date.s hours, minutes, seconds, and time
                         zone.
        toLocaleDateString() - Displays the date.s day of the week, month, day
                         of the month, and year.
        toLocaleTimeString() - Displays the date's hours, minutes, and seconds
        toUTCString() - Displays the complete UTC date

    ** Date/Time Component Methods **


    4. The Function Type
    --------------------

    ** No Overloading **
    ** Function Declaration vs Function Expressions **
    ** Function as Values **
    ** Function Internals **
    ** Function Properties and Methods **


    Some of the most interesting parts of ECMAScript are its functions,
    primarily because functions actually are objects. Each function is an
    instance of the Function type that has properties and methods just like any
    other reference type. Because functions are objects, function names are
    simply pointers to function objects and are not necessarily tied to the
    function itself. Functions are typically defined using function-declaration
    syntax:

    Ex.

        function sum (num1, num2) {
            return num1 + num2;
        }

        var sum = function (num1, num2) {
            return num1 + num2;
        };

    In this code, a variable sum is defined and initialized to be a function.
    Note that there is no name included after the function keyword, because it's
    not needed - the function can be referenced by the variable sum. Also note
    that there is a semicolon after the end of the function, just as there
    would be after any variable initialization.

    The last way to define functions is by using the Function constructor,
    which accepts any number of arguments.

        //not recommended
        var sum = new Function('num1', 'num2', "return num1 + num2");

    This syntax is not recommended because it causes a double interpretation of
    the code.

    Because function names are simply pointers to functions, they act like any
    other variable containing a pointer to an object. This means it's possible
    to have multiple names for a single function.

        function sum(num1, num2){
            return num1 + num2;
        }

        var anotherSum = sum;
        sum = null;
        alert (anotherSum(10, 10));     //20

    Note that using the function name without parentheses accesses the
    function pointer instead of executing the function. When sum is set to null,
    it severs its relationship with the function, although anotherSum() can
    still be called without any problems.

    ** No Overloading **

    Thinking of function names as pointers also explains why there can be no
    function overloading in ECMAScript.


    ** Function Declaration vs Function Expressions **

    Throughout this section, the function declaration and function expression
    are referred to as being almost equivalent. Function declarations are read
    and available in an execution context before any code is executed, whereas
    function expressions aren't complete until the execution reaches that line
    of code.

    Ex.
        alert(sum(10,10));
        var sum = function(num1, num2){
        return num1 + num2;
        };

    This code will cause an error, because the function is part of an
    initialization statement, not part of a function declaration. That means the
    function isn't available in the variable sum until the highlighted line has
    been executed, which won't happen, because the first line causes an
    "unexpected identifier" error.

    ** Function as Values **

    Because function names in ECMAScript are nothing more than variables,
    functions can be used any place any other value can be used. This means it's
    possible not only to pass a function into another function as an argument
    but also to return a function as the result of another function.

    Remember that to access a function pointer instead of executing the
    function, you must leave off the parentheses.

    Returning a function from a function is also possible and can be quite
    useful

    Ex.
        function createComparisonFunction(propertyName) {
            return function(object1, object2){
                var value1 = object1[propertyName];
                var value2 = object2[propertyName];

                if (value1 < value2){
                    return -1;
                } else if (value1 > value2){
                    return 1;
                } else {
                    return 0;
                }
            };
        }

    Essentially it's just a function inside of a function, preceded by the
    return operator. This function can be used as in:

    Ex.
        var data = [{name: 'Zachary', age: 28}, {name: 'Nicholas', age: 29}];
        data.sort(createComparisonFunction('name'));

        alert(data[0].name);                        //Nicholas
        data.sort(createComparisonFunction(.age.));
        alert(data[0].name);                        //Zachary


    ** Function Internals **

    Two special objects exist inside a function: "arguments" and "this". The
    "arguments" object, is an array-like object that contains all of the
    arguments that were passed into the function. Though its primary use is to
    represent function arguments, the arguments object also has a property named
    callee, which is a pointer to the function that owns the arguments object.

    Ex.

        function factorial(num){
            if (num <= 1) {
                return 1;
            } else {
                return num * factorial(num-1)
            }
        }

        -or-

        function factorial(num){
            if (num <= 1) {
                return 1;
            } else {
                return num * arguments.callee(num-1)
            }
        }

    The other special object is called "this", It is a reference to the context
    object that the function is operating on - often called the "this" value
    (when a function is called in the global scope of a web page, the "this"
    object points to window).

    Ex.

        window.color = 'red';
        var o = { color: 'blue' };

        function sayColor(){
            alert(this.color);
        }

        sayColor();                 //'red'
        o.sayColor = sayColor;
        o.sayColor();               //'blue'


    NOTE: Remember that function names are simply variables containing pointers,
          so the global sayColor() function and o.sayColor() point to the same
          function even though they execute in different contexts.


    ECMAScript 5 also formalizes an additional property on a function object:
    "caller".  Which contains a reference to the function that called this
    function or null if the function was called from the global scope.

    When function code executes in strict mode, attempting to access
    arguments.callee results in an error. ECMAScript 5 also defines arguments.
    caller, which also results in an error in strict mode and is always
    undefined outside of strict mode. This is to clear up confusion between
    arguments.caller and the caller property of functions. These changes were
    made as security additions to the language, so third-party code could not
    inspect other code running in the same context.

    Strict mode places one additional restriction: you cannot assign a value to
    the caller property of a function. Doing so results in an error.


    ** Function Properties and Methods **

    Each function has two properties: length and prototype. The length property
    is the number of named arguments that the function expects.

    The prototype property is perhaps the most interesting part of the
    ECMAScript core. The prototype is the actual location of all instance
    methods for reference types, meaning methods such as toString() and valueOf()
    actually exist on the prototype and are then accessed from the object
    instances. This property is very important in terms of defining your
    own reference types and inheritance. In ECMAScript 5, the prototype property
    is not enumerable and so will not be found using for-in.

    There are two additional methods for functions: apply() and call(). These
    methods both call the function with a specific "this" value, effectively
    setting the value of the this object inside the function body. The apply()
    method accepts two arguments: the value of "this" inside the function
    and an array of arguments. This second argument may be an instance of Array,
    but it can also be the arguments object.

    Ex.

        function sum(num1, num2){
            return num1 + num2;
        }

        function callSum1(num1, num2){
            return sum.apply(this, arguments);  //passing in arguments object
        }

        function callSum2(num1, num2){
            return sum.apply(this, [num1, num2]); //passing in array
        }

        alert(callSum1(10,10)); //20
        alert(callSum2(10,10)); //20


    The call() method exhibits the same behavior as apply(), but arguments are
    passed to it differently. The first argument is the this value, but the
    remaining arguments are passed directly into the function. Using call()
    arguments must be enumerated specifically.

        function sum(num1, num2){
            return num1 + num2;
        }

        function callSum(num1, num2){
            return sum.call(this, num1, num2);
        }

        alert(callSum(10,10)); //20


    The decision to use either apply() or call() depends solely on the easiest
    way for you to pass arguments into the function. If you intend to pass in
    the arguments object directly or if you already have an array of data to
    pass in, then apply() is the better choice; otherwise, call() may be a more
    appropriate choice. (If there are no arguments to pass in, these methods are
    identical.)


    NOTE: The main difference is that apply() lets you invoke the function with
          arguments as an array; call() requires the parameters be listed
          explicitly.

          Think of 'a' in apply for array of args and 'c' in call for columns of
          args.


    The true power of apply() and call() lies not in their ability to pass
    arguments but rather in their ability to augment the "this" value inside of
    the function.

        window.color = 'red';
        var o = { color: 'blue' };

        function sayColor(){
            alert(this.color);
        }

        sayColor();             //red
        sayColor.call(this);    //red
        sayColor.call(window);  //red
        sayColor.call(o);       //blue

    The advantage of using call() (or apply()) to augment the scope is that the
    object doesn't need to know anything about the method. In the first version
    of this example, the sayColor() function was placed directly on the object
    "o" before it was called; in the updated example, that step is no longer
    necessary.


    ECMAScript 5 defines an additional method called bind(). The bind() method
    creates a new function instance whose "this" value is bound to the value
    that was passed into bind().

        window.color = 'red';
        var o = { color: 'blue' };

        function sayColor(){
            alert(this.color);
        }

        var objectSayColor = sayColor.bind(o);
        objectSayColor();                       //blue

    Here, a new function called objectSayColor() is created from sayColor() by
    calling bind() and passing in the object o. The objectSayColor() function
    has a this value equivalent to o, so calling the function, even as a global
    call, results in the string 'blue' being displayed. The advantages of
    this technique are discussed in Chapter 22.


    5. Working with primitives and primitive wrappers
    -------------------------------------------------

    ** The Boolean Type **
    ** The Number Type **
    ** The String Type **

    Three special reference types are designed to ease interaction with
    primitive values: the Boolean type, the Number type, and the String type.
    These types can act like the other reference types, but they also have a
    special behavior related to their primitive-type equivalents. Every time a
    primitive value is read, an object of the corresponding primitive wrapper
    type is created behind the scenes, allowing access to any number of methods
    for manipulating the data.

        var s1 = "some text";
        var s2 = s1.substring(2);

    In this code, s1 is a variable containing a string, which is a primitive
    value. On the next line, the substring() method is called on s1 and stored
    in s2. Primitive values aren't objects, so logically they shouldn't have
    methods, though this still works as you would expect. In truth, there is a
    lot going on behind the scenes to allow this seamless operation. When s1 is
    accessed in the second line, it is being accessed in read mode, which is to
    say that its value is being read from memory. Any time a string value is
    accessed in read mode, the following three steps occur:

    1. Create an instance of the String type.
    2. Call the specified method on the instance.
    3. Destroy the instance.

    You can think of these three steps as they're used in the following three
    lines of ECMAScript code:

        var s1 = new String("some text");
        var s2 = s1.substring(2);
        s1 = null;

    This behavior allows the primitive string value to act like an object. These
    same three steps are repeated for Boolean and numeric values using the
    Boolean and Number types, respectively.

    The major difference between reference types and primitive wrapper types is
    the lifetime of the object. When you instantiate a reference type using the
    new operator, it stays in memory until it goes out of scope, whereas
    automatically created primitive wrapper objects exist for only one line of
    code before they are destroyed. This means that properties and methods
    cannot be added at runtime.

        var s1 = "some text";
        s1.color = "red";
        alert(s1.color);                    //undefined

    It is possible to create the primitive wrapper objects explicitly using the
    Boolean, Number, and String constructors. This should be done only when
    absolutely necessary, because it is often confusing for developers as to
    whether they are dealing with a primitive or reference value. Calling typeof
    on an instance of a primitive wrapper type returns "object", and all
    primitive wrapper objects convert to the Boolean value true.

    The Object constructor also acts as a factory method and is capable of
    returning an instance of a primitive wrapper based on the type of value
    passed into the constructor.  For example:

        var obj = new Object("some text");
        alert(obj instanceof String);       //true

    When a string is passed into the Object constructor, an instance of String
    is created; a number argument results in an instance of Number, while a
    Boolean argument returns an instance of Boolean.

    Keep in mind that calling a primitive wrapper constructor using "new" is not
    the same as calling the casting function of the same name.

        var value = '25';
        var number = Number(value);         //casting function
        alert(typeof number);               //'number'
        var obj = new Number(value);        //constructor
        alert(typeof obj);                  //'object'

    Even though it's not recommended to create primitive wrapper objects
    explicitly, their functionality is important in being able to manipulate
    primitive values. Each primitive wrapper type has methods that make data
    manipulation easier.


    ** The Boolean Type **
    ----------------------

    The Boolean type is the reference type corresponding to the Boolean values.
    To create a Boolean object, use the Boolean constructor and pass in either
    true or false.

        var booleanObject = new Boolean(true);

    Instances of Boolean override the valueOf() method to return a primitive
    value of either true or false. The toString() method is also overridden to
    return a string of 'true' or 'false' when called. Unfortunately, not only
    are Boolean objects of little use in ECMAScript, they can actually be rather
    confusing. The problem typically occurs when trying to use Boolean objects
    in Boolean expressions.

    It's very important to understand the difference between a primitive Boolean
    value and a Boolean object - it is recommended to never use the latter.


    ** The Number Type **
    ---------------------

    The Number type is the reference type for numeric values. To create a Number
    object, use the Number constructor and pass in any number.

        var numberObject = new Number(10);

    As with the Boolean type, the Number type overrides valueOf(),
    toLocaleString(), and toString(). The valueOf() method returns the primitive
    numeric value represented by the object, whereas the other two methods
    return the number as a string.

    The toFixed() method returns a string representation of a number with a
    specifi ed number of decimal points:

        var num = 10;
        alert(num.toFixed(2));              //"10.00"

    The toExponential() method returns a string with the number formatted in
    exponential notation (aka e-notation).

        var num = 10;
        alert(num.toExponential(1));        //"1.0e+1"

    The toPrecision() method returns either the fi xed or the exponential
    representation of a number.

        var num = 99;
        alert(num.toPrecision(1));         //"1e+2"
        alert(num.toPrecision(2));         //"99"
        alert(num.toPrecision(3));         //"99.0"


    ** The String Type **
    ---------------------

    The String type is the object representation for strings and is created
    using the String constructor as follows:

        var stringObject = new String("hello world");

    The methods of a String object are available on all string primitives. All
    three of the inherited methods - valueOf(), toLocaleString(), and toString()
    - return the object's primitive string value.

    Each instance of String contains a single property, length, which indicates
    the number of characters in the string.

        var stringValue = "hello world";
        alert(stringValue.length);          //"11"


    String-Manipulation Methods
    ---------------------------

    concat() method:

        var stringValue = "hello ";
        var result = stringValue.concat("world");
        alert(result);                  //"hello world"
        alert(stringValue);             //"hello"

    ECMAScript provides three methods for creating string values from a
    substring: slice(), substr(), and substring(). All three methods return a
    substring of the string they act on, and all accept either one or two
    arguments. The first argument is the position where capture of the substring
    begins; the second argument, if used, indicates where the operation should
    stop.

    There are two methods for locating substrings within another string:
    indexOf() and lastIndexOf(). Both methods search a string for a given
    substring and return the position (or -1 if the substring isn't found). The
    difference between the two is that the indexOf() method begins looking for
    the substring at the beginning of the string, whereas the lastIndexOf()
    method begins looking from the end of the string.

    ECMAScript 5 introduces a trim() method on all strings. The trim() method
    creates a copy of the string, removes all leading and trailing white space,
    and then returns the result.

    Four methods perform case conversion:
    toLowerCase(), toLocaleLowerCase(), toUpperCase(), and toLocaleUpperCase().

    The String type has several methods designed to pattern-match within the
    string. The first of these methods is match() and is essentially the same
    as calling a RegExp object's exec() method. The match() method accepts a
    single argument, which is either a regular-expression string or a RegExp
    object.

        var text = "cat, bat, sat, fat";
        var pattern = /.at/;

        //same as pattern.exec(text)
        var matches = text.match(pattern);
        alert(matches.index);               //0
        alert(matches[0]);                  //"cat"
        alert(pattern.lastIndex);           //0


    Another method for finding patterns is search(). The only argument for this
    method is the same as the argument for match(): a regular expression
    specified by either a string or a RegExp object. The search() method returns
    the index of the first pattern occurrence in the string or -1 if it's not
    found. search() always begins looking for the pattern at the beginning of
    the string.

        var text = "cat, bat, sat, fat";
        var pos = text.search(/at/);
        alert(pos); //1

    To simplify replacing substrings, ECMAScript provides the replace() method.
    This method accepts two arguments.

        var text = "cat, bat, sat, fat";
        var result = text.replace('at', 'ond');
        alert(result);                          //'cond, bat, sat, fat'
        result = text.replace(/at/g, 'ond');
        alert(result);                          //'cond, bond, sond, fond'


    6. Singleton Built-in Objects
    -----------------------------

    ** Global Object **
    ** Math Object **

    ECMA-262 defines a built-in object as "any object supplied by an ECMAScript
    implementation, independent of the host environment, which is present at the
    start of the execution of an ECMAScript program". This means the developer
    does not need to explicitly instantiate a built-in object; it is already
    instantiated.

    There are two singleton built-in objects defined by ECMA-262: Global and
    Math.


    ** Global Object **
    -------------------

    The Global object is the most unique in ECMAScript, because it isn't
    explicitly accessible. ECMA-262 specifies the Global object as a sort of
    catchall for properties and methods that don't otherwise have an owning
    object. In truth, there is no such thing as a global variable or global
    function; all variables and functions defined globally become properties of
    the Global object.  Functions covered earlier, such as isNaN(), isFinite(),
    parseInt(), and parseFloat() are actually methods of the Global object. In
    addition to these, there are several other methods available on the Global
    object.

    The encodeURI() and encodeURIComponent() methods are used to encode URIs
    (Uniform Resource Identifiers) to be passed to the browser. To be valid, a
    URI cannot contain certain characters, such as spaces. The URI-encoding
    methods encode the URIs so that a browser can still accept and understand
    them, replacing all invalid characters with a special UTF-8 encoding.

    NOTE: Generally speaking, you'll use encodeURIComponent() much more
          frequently than encodeURI(), because it's more common to encode query
          string arguments separately from the base URI.


    The eval() Method
    -----------------

    The final method is perhaps the most powerful in the entire ECMAScript
    language: the eval() method. This method works like an entire ECMAScript
    interpreter and accepts one argument, a string of ECMAScript (or JavaScript)
    to execute.

        eval("alert('hi')");

    This line is functionally equivalent to the following:

        alert('hi');

    When the interpreter finds an eval() call, it interprets the argument into
    actual ECMAScript statements and then inserts it into place. Code executed by
    eval() is considered to be part of the execution context in which the call
    is made, and the executed code has the same scope chain as that context.
    This means variables that are defined in the containing context can be
    referenced inside an eval() call.

        var msg = "hello world";
        eval("alert(msg)"); //"hello world"

    Likewise, you can define a function or variables inside an eval() call that
    can be referenced by the code outside.

        eval("function sayHi() { alert('hi'); }");
        sayHi();

    Any variables or functions created inside of eval() will not be hoisted, as
    they are contained within a string when the code is being parsed. They are
    created only at the time of eval() execution.

    In strict mode, variables and functions created inside of eval() are not
    accessible outside, so these last two examples would cause errors. Also,
    in strict mode, assigning a value to eval causes an error:

        "use strict";
        eval = 'hi'; //causes error

    NOTE: The capability to interpret strings of code is very powerful but also
          very dangerous. Use extreme caution with eval(), especially when
          passing userentered data into it. A mischievous user could insert
          values that might compromise your site or application security. (This
          is called code injection.)


    ** Math Object **

    ECMAScript provides the Math object as a common location for mathematical
    formulas and information. The computations available on the Math object
    execute faster than if you were to write the computations in JavaScript
    directly.

    The min() and max() methods determine which number is the smallest or
    largest in a group of numbers.

        var max = Math.max(3, 54, 32, 16);
        alert(max);                         //54

        var min = Math.min(3, 54, 32, 16);
        alert(min);                         //3

    The Math.random() method returns a random number between the 0 and the 1,
    not including either 0 or 1. This is a favorite tool of web sites that are
    trying to display random quotes or random facts upon entry of a web site.
    You can use Math.random() to select numbers within a certain integer
    range by using the following formula:

        number = Math.floor(Math.random() * total_number_of_choices +
                 first_possible_value)

    The Math.floor() method is used here because Math.random() always returns a
    decimal value, meaning that multiplying it by a number and adding another
    still yields a decimal value. So, if you wanted to select a number between 1
    and 10, the code would look like this:

        var num = Math.floor(Math.random() * 10 + 1);

    You see 10 possible values (1 through 10), with the first possible value
    being 1. If you want to select a number between 2 and 10, then the code
    would look like this:

        var num = Math.floor(Math.random() * 9 + 2);

    There are only nine numbers when counting from 2 to 10, so the total number
    of choices is nine, with the first possible value being 2. Many times, it's
    just easier to use a function that handles the calculation of the total
    number of choices and the first possible value,

        function selectFrom(lowerValue, upperValue) {
            var choices = upperValue - lowerValue + 1;
            return Math.floor(Math.random() * choices + lowerValue);
        }

        var num = selectFrom(2,10);
        alert(num);                 //number between 2 and 10, inclusive

    Using the function, it's easy to select a random item from an array, as
    shown here:

        var colors = ['red', 'green', 'blue', 'yellow', 'black', 'purple'];
        var color = colors[selectFrom(0, colors.length-1)];

    In this example, the second argument to selectFrom() is the length of the
    array minus 1, which is the last position in an array.


    7. Summary
    ----------

    Objects in JavaScript are called reference values, and several built-in
    reference types can be used to create specific types of objects, as follows:

        - Reference types are similar to classes in traditional object-oriented
          programming but are implemented differently.  The Object type is the
          base from which all other reference types inherit basic behavior.
        - The Array type represents an ordered list of values and provides
          functionality for manipulating and converting the values.
        - The Date type provides information about dates and times, including the
          current date and time and calculations.
        - The RegExp type is an interface for regular-expression support in
          ECMAScript, providing most basic and some advanced regular-expression
          functionality.

    One of the unique aspects of JavaScript is that functions are actually
    instances of the Function type, meaning functions are objects. Because
    functions are objects, functions have methods that can be used to augment
    how they behave.

    Because of the existence of primitive wrapper types, primitive values in
    JavaScript can be accessed as if they were objects. There are three
    primitive wrapper types: Boolean, Number, and String.

    They all have the following characteristics:

        - Each of the wrapper types maps to the primitive type of the same name.
        - When a primitive value is accessed in read mode, a primitive wrapper
          object is instantiated so that it can be used to manipulate the data.
        - As soon as a statement involving a primitive value is executed, the
          wrapper object is destroyed.

    There are also two built-in objects that exist at the beginning of code
    execution: Global and Math.

    The Global object isn't accessible in most ECMAScript implementations;
    however, web browsers implement it as the window object. The Global object
    contains all global variables and functions as properties. The Math object
    contains properties and methods to aid in complex mathematical calculations.


================================================================================


                      CHAP  6: OBJECT-ORIENTED PROGRAMMING
                      ------------------------------------


    1. Understanding object properties
    2. Understanding and creating objects
    3. Understanding inheritance
    4. Summary

    Object-oriented (OO) languages typically are identified through their use
    of classes to create multiple objects that have the same properties and
    methods. As mentioned previously, ECMAScript has no concept of classes, and
    therefore objects are different than in class-based languages.

    ECMA-262 defines an object as an unordered collection of properties each
    of which contains a primitive value, object, or function. Strictly speaking,
    this means that an object is an array of values in no particular order. Each
    property or method is identified by a name that is mapped to a value. For
    this reason (and others yet to be discussed), it helps to think of ECMAScript
    objects as hash tables: nothing more than a grouping of name-value pairs where
    the value may be data or a function.

    Each object is created based on a reference type, either one of the native
    types discussed in the previous chapter, or a developer-defined type.

    1. Understanding object properties
    ----------------------------------

    ** Types of Properties **
    ** Defining Multiple Properties **
    ** Reading Property Attributes **

    Ex. Create an Object (old style):

        var person  = new Object();
        person.name = "Nicholas";
        person.age  = 29;
        person.job  = "Developer";

        person.SayName = function () {
            console.log(this.name)
        }


    Ex. Create an Object (newer style using object literal notation):

        var person = {
            name: "Nicholas",
            age : 29,
            job : "Developer",
            sayName : function () {
                console.log(this.name)
            }
        }

    The Property (object attribute)

    Properties are variables contained in the class; every instance of the
    object has those properties. Properties should be set in the prototype
    property of the class (function) so that inheritance works correctly.

    Working with properties from within the class is done by the keyword "this"
    which refers to the current object. Accessing (reading or writing) a
    property outside of the class is done with the syntax:
    InstanceName.Property; this is the same syntax used by C++, Java, and a
    number of other languages. (Inside the class the syntax this.Property is
    used to get or set the property's value.)

    ** Types of Properties **

    ECMA-262 fifth edition describes characteristics of properties through the
    use of internal-only attributes. These attributes are defined by the
    specification for implementation in JavaScript engines, and as such, these
    attributes are not directly accessible in JavaScript. To indicate that an
    attribute is internal, surround the attribute name with two pairs of square
    brackets, such as [[Enumerable]


    There are two types of properties:
        - DATA PROPERTIES
        - ACCESSOR PROPERTIES

    DATA PROPERTIES
    ----------------

    Data Properties contain a single location for a data value. Values are read
    from and written to this location. Data properties have four attributes
    describing their behavior

    [[Configurable]] - Indicates if the property may be redefined by removing
                       the property via delete, changing the property's
                       attributes, or changing the property into an accessor
                       property. By default, this is true for all properties
                       defined directly on an object, as in previous example.

    [[Enumerable]]   - Indicates if the property will be returned in a for-in
                       loop. By default, this is true for all properties defined
                       directly on an object, as in the previous example.

    [[Writable]]     - Indicates if the property's value can be changed. By
                       default, this is true for all properties defined
                       directly on an object, as in the previous example.

    [[Value]]        - Contains the actual data value for the property. This is the
                       location from which the property's value is read and the
                       location to which new values are saved. The default value
                       for this attribute is undefined.

    When a property is explicitly added to an object: [[Configurable]],
    [[Enumerable]], and [[Writable]] are all set to true while the [[Value]]
    attribute is set to the assigned value.

    To change any of the default property attributes, you must use the
    ECMAScript 5 Object.defineProperty() method.

    Although you can call Object.defineProperty() multiple times for the same
    property, there are limits once configurable has been set to false.

    When you are using Object.defineProperty(), the values for configurable,
    enumerable, and writable default to false unless otherwise specified. In
    most cases, you likely won't need the powerful options provided by
    Object.defineProperty(), but it's important to understand the concepts to
    have a good understanding of JavaScript objects.


    ACCESSOR PROPERTIES
    -------------------

    Accessor Properties - do not contain a data value. Instead, they contain a
    combination of a getter function and a setter function (though both are not
    necessary). When an accessor property is read from, the getter function is
    called, and it's the function's responsibility to return a valid value; when
    an accessor property is written to, a function is called with the new value,
    and that function must decide how to react to the data. Accessor properties
    have four attributes:

    [[Configurable]] - Indicates if the property may be redefined by removing
                       the property via delete, changing the property's
                       attributes, or changing the property into data property.
                       By default, this is true for all properties defined
                       directly on an object.

    [[Enumerable]]   - Indicates if the property will be returned in a for-in
                       loop. By default, this is true for all properties defined
                       directly on an object.

    [[Get]]          - The function to call when the property is read from. The
                       default value is undefined.

    [[Set]]          - The function to call when the property is written to. The
                       default value is undefined.

    It is not possible to define an accessor property explicitly; you must use
    Object.defineProperty().

    It's not necessary to assign both a getter and a setter.  Assigning just a
    getter means that the property cannot be written to and attempts to do so
    will be ignored.

    NOTE: Common convention when using a variable that is not intended to be
          accessed from the outside of the object's method is to use underscore
          notation (ie. _var1, _year1).


    ** Defining Multiple Properties **

    Since there's a high likelihood that you'll need to define more than one
    property on an object, ECMAScript 5 provides the Object.defineProperties()
    method. This method allows you to define multiple properties using
    descriptors at once.


    ** Reading Property Attributes **

    It's also possible to retrieve the property descriptor for a given property
    by using the ECMAScript 5 Object.getOwnPropertyDescriptor() method. This
    method accepts two arguments: the object on which the property resides and
    the name of the property whose descriptor should be retrieved. The
    return value is an object with properties for configurable, enumerable, get,
    and set for accessor properties or configurable, enumerable, writable, and
    value for data properties.


    2. Understanding and creating objects
    -------------------------------------


    - FACTORY PATTERN
    - CONSTRUCTOR PATTERN
    - PROTOTYPE PATTERN
    - COMBINATION CONSTRUCTOR/PROTOTYPE PATTERN
    - DYNAMIC PROTOTYPE PATTERN
    - PARASITIC CONSTRUCTOR PATTERN
    - DURABLE CONSTRUCTOR PATTERN


    - FACTORY PATTERN Doesn't explicitly require us to use a constructor.
                      Instead, a Factory can provide a generic interface for
                      creating objects, where we can specify the type of
                      factory object we wish to be created.

    Ex.

        function createPerson(name, age, job) {
            var o = new Object();
            o.name = name;
            o.age  = age;
            o.job  = job;
            o.sayName = function () {
                console.log(this.name);
                console.log('You are %d and %s', this.age, this.job);
            };
            return o;
        }

        var p1 = createPerson('Nicholas', 29, 'Software Engineer');
        var p2 = createPerson('Greg', 27, 'Doctor');

        p1.sayName();
        p2.sayName();


                ------


    - CONSTRUCTOR PATTERN Constructors in ECMAScript are used to create specific
                          types of objects. There are native constructors, such
                          as Object and Array, which are available automatically
                          in the execution environment at runtime. It is also
                          possible to define custom constructors that define
                          properties and methods for your own type of object.

    Ex.

        function Person(name, age, job) {
            this.name = name;
            this.age  = age;
            this.job  = job;
            this.sayName = function () {
                alert("Hello %s, you're %d and %s", this.name, this.age, this.job);
            };
        }

        var p1 = new Person('Nicholas', 29, 'Software Engineer');
        var p2 = new Person('Greg', 27, 'Doctor');

        p1.sayName();
        p2.sayName();


    NOTE:
    - There is no object being created explicitly.
    - The properties and method are assigned directly onto the this object.
    - There is no return statement. And the use of 'new' operator.
    - By convention, constructor functions always begin with an uppercase letter,
      whereas nonconstructor functions begin with a lowercase letter. This
      convention is borrowed from other OO languages and helps to distinguish
      function use in ECMAScript, since constructors are simply functions that
      create objects.

    Calling a constructor in this manner essentially causes the following four
    steps to be taken:

        1. Create a new object.
        2. Assign the "this" value of the constructor to the new object (so
           "this" points to the new object).
        3. Execute the code inside the constructor (adds properties to the new
           object).
        4. Return the new object.

    At the end of the preceding example, person1 and person2 are each filled
    with a different instance of Person. Each of these objects has a constructor
    property that points back to Person, as follows:

        alert(person1.constructor == Person); //true
        alert(person2.constructor == Person); //true

    The constructor property was originally intended for use in identifying the
    object type. However, the instanceof operator is considered to be a safer
    way of determining type.

        alert(person1 instanceof Object); //true
        alert(person1 instanceof Person); //true

    Defining your own constructors ensures that instances can be identified as
    a particular type later on, which is a great advantage over the factory
    pattern.


    Constructors as Functions
    -------------------------

    The only difference between constructor functions and other functions is the
    way in which they are called. Constructors are, after all, just functions;
    there's no special syntax to define a constructor that automatically makes
    it behave as such. Any function that is called with the new operator acts as
    a constructor, whereas any function called without it acts just as you
    would expect a normal function call to act.

    Remember that "this" object always points to the Global object (window in
    web browsers) when a function is called without an explicitly set "this"
    value (by being an object method or through call()/apply()).


    Problems with Constructors
    --------------------------

    The major downside to constructors is that methods are created once for each
    instance. So, in the previous example, both person1 and person2 have a
    method called sayName(), but those methods are not the same instance of
    Function. Remember, functions are objects in ECMAScript, so every time a
    function is defined, it's actually an object being instantiated.

    It doesn't make sense to have two instances of Function that do the same
    thing, especially when the "this" object makes it possible to avoid binding
    functions to particular objects until runtime.

    It's possible to work around this limitation by moving the function
    definition outside of the constructor,

        function Person(name, age, job){
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = sayName;
        }

        function sayName(){
            alert(this.name);
        }

        var person1 = new Person("Nicholas", 29, "Software Engineer");
        var person2 = new Person("Greg", 27, "Doctor");


                ------


    - PROTOTYPE PATTERN Each function is created with a "prototype" property,
                        which is an object containing properties and methods
                        that should be available to instances of a particular
                        reference type. This object is literally a prototype for
                        the object to be created once the constructor is called.
                        The benefit of using the prototype is that all of its
                        properties and methods are shared among object instances.
                        Instead of assigning object information in the
                        constructor, they can be assigned directly to the prototype.

    Ex.

        function Person() {
        }

        Person.prototype.name = "Nicholas";
        Person.prototype.age  = 29;
        Person.prototype.job  = "Software Engineer";
        Person.prototype.sayName = function () {
            console.log(this.name)
        }

        var p1 = new Person();
        p1.sayName();


    Whenever a function is created, its prototype property is also created
    according to a specific set of rules. By default, all prototypes
    automatically get a property called constructor that points back to the
    function on which it is a property.

    Although it's possible to read values on the prototype from object
    instances, it is not possible to overwrite them. If you add a property to
    an instance that has the same name as a property on the prototype, you
    create the property on the instance, which then masks the property on the
    prototype.


    NOTE: Since the process of looking up values on a prototype is a search,
          changes made to the prototype at any point are immediately reflected
          on instances, even the instances that existed before the change was
          made.


    Alternate Prototype Syntax
    --------------------------

    To limit redundancy and to better visually encapsulate functionality on
    the prototype, it has become more common to simply overwrite the prototype
    with an object literal that contains all of the properties and methods,

    Ex.

        function Person(){}

        Person.prototype = {
            name : Nicholas,
            age  : 29,
            job  : Software Engineer,
            sayName : function () {
                console.log(this.name);
            }
        };

    In this rewritten example, the Person.prototype property is set equal to a
    new object created with an object literal. The end result is the same, with
    one exception: the constructor property no longer points to Person.

    If the constructor's value is important, you can set it specifically back
    to the appropriate value,

    Ex.

        function Person(){}

        Person.prototype = {
            constructor: Person,
            ...
            ...
            }
        };


    Why is Prototype Important and When is it Used?
    -----------------------------------------------

    1. Prototype Property: Prototype-based Inheritance

       Prototype is important in JavaScript because JavaScript does not have
       classical inheritance based on Classes (as most object oriented languages
       do), and therefore all inheritance in JavaScript is made possible through
       the prototype property. JavaScript has a prototype-based inheritance
       mechanism.  Inheritance is a programming paradigm where objects (or
       Classes in some languages) can inherit properties and methods from other
       objects (or Classes). In JavaScript, you implement inheritance with the
       prototype property.


    2. Prototype Attribute: Accessing Properties on Objects

       Prototype is also important for accessing properties and methods of
       objects. The prototype attribute (or prototype object) of any object is
       the "parent" object where the inherited properties were originally
       defined. This is loosely analogous to the way you might inherit your
       surname from your father-he is your "prototype parent". If we wanted to
       find out where your surname came from, we would first check to see if you
       created it yourself; if not, the search will move to your prototype
       parent to see if you inherited it from him. If it was not created by him,
       the search continues to his father (your father's prototype parent).

       Similarly, if you want to access a property of an object, the search for
       the property begins directly on the object. If the JS runtime can't find
       the property there, it then looks for the property on the object's
       prototype.the object it inherited its properties from.

       If the property is not found on the object's prototype, the search for
       the property then moves to prototype of the object's prototype (the
       father of the object's father-the grandfather). And this continues until
       there is no more prototype (no more great-grand father; no more lineage
       to follow).



    Problems with Prototypes
    ------------------------

    It negates the ability to pass initialization arguments into the
    constructor, meaning that all instances get the same property values by
    default.  Although this is an inconvenience, it isn't the biggest problem
    with prototypes. The main problem comes with their shared nature.

    All properties on the prototype are shared among instances, which is ideal
    for functions. Properties that contain primitive values also tend to work
    well, where it's possible to hide the prototype property by assigning a
    property of the same name to the instance.  The real problem occurs when a
    property contains a reference value.

    Typically, though, instances want to have their own copies of all properties.
    This is why the prototype pattern is rarely used on its own.


                                      ---


    - COMBINATION CONSTRUCTOR/PROTOTYPE PATTERN
                  The most common way of defining custom types is to combine the
                  constructor and prototype patterns. The constructor pattern
                  defines instance properties, whereas the prototype pattern
                  defines methods and shared properties. With this approach,
                  each instance ends up with its own copy of the instance
                  properties, but they all share references to methods,
                  conserving memory. This pattern allows arguments to be passed
                  into the constructor as well, effectively combining the best
                  parts of each pattern.

    Ex.

        function Person(name, age, job) {
            this.name = name;
            this.age  = age;
            this.job  = job;
            this.friends = ['Shelby', 'Court'];
        }

        Person.prototype = {
            constructor : Person,
            sayName : function() {console.log(this.name); }
        };

        var p1 = new Person('Nicholas', 29, 'Software Engineer');
        var p2 = new Person('Greg', 30, 'Doctor');

        p1.friends.push('Vans');

        console.log(p1.friends);
        console.log(p2.friends);


    The hybrid constructor/prototype pattern is the most widely used and
    accepted practice for defining custom reference types in ECMAScript.
    Generally speaking, this is the default pattern to use for defining
    reference types.


                -----


    - DYNAMIC PROTOTYPE PATTERN The dynamic prototype pattern encapsulate all of
              of the information within the constructor while maintaining the
              benefits of using both a constructor and a prototype by
              initializing the prototype inside the constructor, but only if it
              is needed.  You can determine if the prototype needs to be
              initialized by checking for the existence of a method that should
              be available.

    Ex.

        function Person(name, age, job) {
            this.name = name;
            this.age  = age;
            this.job  = job;
            this.friends = ['Shelby', 'Court'];

            if (typeof this.sayName != 'function') {
                Person.prototype.sayName = function () {
                    console.log(this.name);
                };
            }
        }

    The "if (typeof this.sayName != 'function')" is executed only the first
    time the constructor is called. After that, the prototype has been
    initialized and doesn't need any further modification. Remember that
    changes to the prototype are reflected immediately in all instances, so
    this approach works perfectly.  The if statement may check for any property
    or method that will be present once initialized - there's no need for
    multiple 'if' statements to check each property or method; any one will do.
    This pattern preserves the use of instanceof in determining what type of
    object was created.


    NOTE: You cannot overwrite the prototype using an object literal when using
          the dynamic prototype pattern. As described previously, overwriting a
          prototype when an instance already exists effectively cuts off that
          instance from the new prototype.


                -----


    - PARASITIC CONSTRUCTOR PATTERN
                The basic idea of this pattern is to create a constructor that
                simply wraps the creation and return of another object while
                looking like a typical constructor.

    This is exactly the same as the factory pattern except that the function is
    called as a constructor, using the new operator. When a constructor doesn't
    return a value, it returns the new object instance by default. Adding a
    return statement at the end of a constructor allows you to override the
    value that is returned when the constructor is called.

    A few important things to note about this pattern: there is no relationship
    between the returned object and the constructor or the constructor's
    prototype; the object exists just as if it were created outside of a
    constructor. This pattern should not be used when other patterns work.


    - DURABLE CONSTRUCTOR PATTERN
                Durable objects are best used in secure environments (those that
                forbid the use of "this" and "new") or to protect data from the
                rest of the application (as in mashups).



    3. Understanding inheritance
    ----------------------------


    ** Prototype Chaining **
    ** Constructor Stealing **
    ** Combination Inheritance **
    ** Prototypal Inheritance **
    ** Parasitic Inheritance **
    ** Parasitic Combination Inheritance **


    The concept most often discussed in relation to OO programming is
    inheritance. Many OO languages support two types of inheritance:

        - Interface inheritance, where only the method signatures are inherited.
        - Implementation inheritance, where actual methods are inherited.

    Interface inheritance is not possible in ECMAScript, because functions do not
    have signatures. Implementation inheritance is the only type of inheritance
    supported by ECMAScript, and this is done primarily through the use of
    prototype chaining.


    ** Prototype Chaining **
    ------------------------

    Prototype chaining is the primary method of inheritance in ECMAScript.  The
    basic idea is to use the concept of prototypes to inherit properties and
    methods between two reference types. Recall the relationship between
    constructors, prototypes, and instances: each constructor has a prototype
    object that points back to the constructor, and instances have an internal
    pointer to the prototype.

    What if the prototype were actually an instance of another type?  That would
    mean the prototype itself would have a pointer to a different prototype
    that, in turn, would have a pointer to another constructor. If that
    prototype were also an instance of another type, then the pattern would
    continue, forming a chain between instances and prototypes. This is the
    basic idea behind prototype chaining.


        function SuperType() {
            this.property = true;
        }

        SuperType.prototype.getSuperValue = function () {
            return this.property;
        };

        function SubType() {
            this.subproperty = false;
        }

        // inherit from SuperType
        SubType.prototype = new SuperType();

        SubType.prototype.getSubValue = function () {
            return this.subproperty;
        };

        var instance = new SubType();
        alert(instance.getSuperValue());        //true


    Instead of using the default prototype of SubType, a new prototype is
    assigned. That new prototype happens to be an instance of SuperType, so it
    not only gets the properties and methods of a SuperType instance but also
    points back to the SuperType's prototype. So instance points to
    SubType.prototype, and SubType.prototype points to SuperType.prototype. Note
    that the getSuperValue() method remains on the SuperType.prototype object,
    but property ends up on SubType.prototype. That's because getSuperValue() is
    a prototype method, and property is an instance property. SubType.prototype
    is now an instance of SuperType, so property is stored there. Also note that
    instance.constructor points to SuperType, because the constructor property
    on the SubType.prototype was overwritten.

    Prototype chaining extends to the prototype search mechanism described
    earlier. As you may recall, when a property is accessed in read mode on an
    instance, the property is first searched for on the instance. If the
    property is not found, then the search continues to the prototype. When
    inheritance has been implemented via prototype chaining, that search can
    continue up the prototype chain.

    In reality, there is another step in the prototype chain. All reference
    types inherit from Object by default, which is accomplished through
    prototype chaining. The default prototype for any function is an instance of
    Object, meaning that its internal prototype pointer points to
    Object.prototype. This is how custom types inherit all of the default
    methods such as toString() and valueOf(). So the previous example has an
    extra layer of inheritance.

    The relationship between prototypes and instances is discernible in two
    ways. The first way is to use the instanceof operator, which returns true
    whenever an instance is used with a constructor that appears in its
    prototype chain,

        alert(instance instanceof Object);      //true
        alert(instance instanceof SuperType);   //true
        alert(instance instanceof SubType);     //true


    The second way to determine this relationship is to use the isPrototypeOf()
    method.

        alert(Object.prototype.isPrototypeOf(instance));    //true
        alert(SuperType.prototype.isPrototypeOf(instance)); //true
        alert(SubType.prototype.isPrototypeOf(instance));   //true


    Working with Methods
    --------------------

    Often a subtype will need to either override a supertype method or introduce
    new methods that don't exist on the supertype. To accomplish this, the
    methods must be added to prototype after the prototype has been assigned.

        ...
        ...

        //new method
        SubType.prototype.getSubValue = function (){
            return this.subproperty;
        };

        //override existing method
            SubType.prototype.getSuperValue = function (){
            return false;
        };

        var instance = new SubType();
        alert(instance.getSuperValue()); //false


    The important thing to note is that both of the methods are defined after
    the prototype has been assigned as an instance of SuperType. Another
    important thing to understand is that the object literal approach to
    creating prototype methods cannot be used with prototype chaining, because
    you end up overwriting the chain.

        ...
        ...

        //try to add new methods - this nullifies the previous line
        SubType.prototype = {
            getSubValue : function (){
                return this.subproperty;
            },

            someOtherMethod : function (){
                    return false;
            }
        };

        var instance = new SubType();
        alert(instance.getSuperValue()); //error!



    Problems with Prototype Chaining
    --------------------------------

    Even though prototype chaining is a powerful tool for inheritance, it is not
    without its issues.

    The major issue revolves around prototypes that contain reference values.
    Prototype properties containing reference values are shared with all
    instances; this is why properties are typically defined within the
    constructor instead of on the prototype.  When implementing inheritance
    using prototypes, the prototype actually becomes an instance of another
    type, meaning that what once were instance properties are now prototype
    properties.

    Ex.

        function SuperType() {
            this.colors = ['red', 'blue', 'green'];
        }

        function SubType() { }

        SubType.prototype = new SuperType();

        var instance1 = new SubType();
        instance1.colors.push('black');
        alert(instance1.colors);            //red, blue, green, black

        var instance2 = new SubType();
        alert(instance2.colors);            //red, blue, green, black


    ** Constructor Stealing **
    --------------------------

    Sometimes called object masquerading or classical inheritance. The basic
    idea is quite simple: call the supertype constructor from within the subtype
    constructor. Keeping in mind that functions are simply objects that execute
    code in a particular context, the apply() and call() methods can be used to
    execute a constructor on the newly created object,

        function SuperType(){
            this.colors = ['red', 'blue', 'green'];
        }

        function SubType(){
            //inherit from SuperType
            SuperType.call(this);
        }

        var instance1 = new SubType();

        instance1.colors.push('black');
        alert(instance1.colors);        //"red,blue,green,black"

        var instance2 = new SubType();
        alert(instance2.colors);        //"red,blue,green"


    By using the call() method (or alternately, apply()), the SuperType
    constructor is called in the context of the newly created instance of
    SubType. Doing this effectively runs all of the object-initialization
    code in the SuperType() function on the new SubType object. The result is
    that each instance has its own copy of the colors property.

    Passing Arguments
    -----------------

    One advantage that constructor stealing offers over prototype chaining is
    the ability to pass arguments into the supertype constructor from within the
    subtype constructor.

        function SuperType(name) {
            this.name = name;
        }

        function SubType() {
            //inherit from SuperType passing in an argument
            SuperType.call(this, "Nicholas");

            //instance property
            this.age = 29;
        }

        var instance = new SubType();
        alert(instance.name);       //Nicholas
        alert(instance.age);        //29


    Problems with Constructor Stealing
    ----------------------------------

    The downside to using constructor stealing exclusively is that it introduces
    the same problems as the constructor pattern for custom types: methods must
    be defined inside the constructor, so there's no function reuse.
    Furthermore, methods defined on the supertype's prototype are not accessible
    on the subtype, so all types can use only the constructor pattern. Because
    of these issues, constructor stealing is rarely used on its own.


    ** Combination Inheritance **
    -----------------------------

    Sometimes also called pseudoclassical inheritance - combines prototype
    chaining and constructor stealing to get the best of each approach. The
    basic idea is to use prototype chaining to inherit properties and methods on
    the prototype and to use constructor stealing to inherit instance
    properties. This allows function reuse by defining methods on the prototype
    and allows each instance to have its own properties.

        function SuperType(name) {
            this.name = name;
            this.colors = ['red', 'blue', 'green'];
        }

        SuperType.prototype.sayName = function() {
            alert(this.name);
        };

        function SubType(name, age) {
            //inherit properties
            SuperType.call(this, name);

            this.age = age;
        }

        // inherit methods
        SubType.prototype = new SuperType();

        SubType.prototype.sayAge = function() {
            alert(this.age);
        }

        var instance = new SubType('Nicholas', 29);
        instance.colors.push('black);
        alert(instance.colors);             //red, blue, green, black
        instance.SayName();                 //Nicholas
        instance.sayAge();                  //29

        var instance2 = new SubType('Greg', 27);
        alert(instance2.colors);            //red, blue, green
        instance2.SayName();                //Greg
        instance2.sayAge();                 //27



    With this code, it's then possible to create two separate instances of
    SubType that have their own properties, including the colors property, but
    all use the same methods.

    Addressing the downsides of both prototype chaining and constructor
    stealing, Combination Inheritance is the most frequently used inheritance
    pattern in JavaScript.  It also preserves the behavior of instanceof and
    isPrototypeOf() for identifying the composition of objects.


    ** Prototypal Inheritance **
    ----------------------------

    In 2006, Douglas Crockford wrote an article titled "Prototypal Inheritance
    in JavaScript" in which he introduced a method of inheritance that didn't
    involve the use of strictly defined constructors. His premise was that
    prototypes allow you to create new objects based on existing objects without
    the need for defining custom types.

        function object(o){
            function F(){}
            F.prototype = o;
            return new F();
        }


    The object() function creates a temporary constructor, assigns a given
    object as the constructor's prototype, and returns a new instance of the
    temporary type. Essentially, object() performs a shadow copy of any object
    that is passed into it.

        var person = {
            name: 'Nicholas',
            friends: ['Shelby', 'Court', 'Van']
        };

        var anotherPerson = object(person);
        anotherPerson.name = 'Greg';
        anotherPerson.friends.push('Rob');

        var yetAnotherPerson = object(person);
        yetAnotherPerson.name = 'Linda';
        yetAnotherPerson.friends.push('Barbie');

        alert(person.friends);                  //"Shelby,Court,Van,Rob,Barbie"


    You have an object that you want to use as the base of another object. That
    object should be passed into object(), and the resulting object should be
    modified accordingly. In this example, the person object contains
    information that should be available on another object, so it is passed into
    the object() function, which returns a new object.

    ECMAScript 5 formalized the concept of prototypal inheritance by adding the
    Object.create() method. This method accepts two arguments, an object to use
    as the prototype for a new object and an optional object defining additional
    properties to apply to the new object. When used with one argument,
    Object.create() behaves the same as the object() method.


        var person = {
            name: 'Nicholas',
            friends: ['Shelby', 'Court', 'Van']
        };

        var anotherPerson = Object.create(person);
        anotherPerson.name = 'Greg';
        anotherPerson.friends.push('Rob');

        var yetAnotherPerson = Object.create(person);
        yetAnotherPerson.name = 'Linda';
        yetAnotherPerson.friends.push('Barbie');

        alert(person.friends);                  //"Shelby,Court,Van,Rob,Barbie"


    Prototypal inheritance is useful when there is no need for the overhead of
    creating separate constructors, but you still need an object to behave
    similarly to another.  Keep in mind that properties containing reference
    values will always share those values, similar to using the prototype
    pattern.


    ** Parasitic Inheritance **
    ---------------------------

    Closely related to prototypal inheritance is the concept of parasitic
    inheritance, another pattern popularized by Crockford. The idea behind
    parasitic inheritance is similar to that of the parasitic constructor and
    factory patterns: create a function that does the inheritance, augments the
    object in some way, and then returns the object as if it did all the work.

    Parasitic inheritance is another pattern to use when you are concerned
    primarily with objects and not with custom types and constructors.


    NOTE: Keep in mind that adding functions to objects using parasitic
          inheritance leads to inefficiencies related to function reuse,
          similar to the constructor pattern.



    ** Parasitic Combination Inheritance **
    ---------------------------------------

    Combination inheritance is the most often-used pattern for inheritance in
    JavaScript, though it is not without its inefficiencies. The most
    inefficient part of the pattern is that the supertype constructor is always
    called twice: once to create the subtype's prototype, and once inside the
    subtype constructor. Essentially, the subtype prototype ends up with all of
    the instance properties of a supertype object, only to have it overwritten
    when the subtype constructor executes.

    Parasitic combination inheritance uses constructor stealing to inherit
    properties but uses a hybrid form of prototype chaining to inherit methods.
    The basic idea is this: instead of calling the supertype constructor to
    assign the subtype's prototype, all you need is a copy of the supertype's
    prototype. Essentially, use parasitic inheritance to inherit from the
    supertype's prototype and then assign the result to the subtype's prototype.


    4. Summary
    ----------

    ECMAScript supports object-oriented (OO) programming without the use of
    classes or interfaces.  Objects are created and augmented at any point
    during code execution, making objects into dynamic rather than strictly
    defined entities. In place of classes, the following patterns are used for
    the creation of objects:

        - The factory pattern uses a simple function that creates an object,
          assigns properties and methods, and then returns the object. This
          pattern fell out of favor when the constructor pattern emerged.

        - Using the constructor pattern, it's possible to define custom
          reference types that can be created using the "new" operator in the
          same way as built-in object instances are created. The constructor
          pattern does have a downside, however, in that none of its members are
          reused, including functions. Since functions can be written in a
          loosely typed manner, there's no reason they cannot be shared by
          multiple object instances.

        - The prototype pattern takes this into account, using the constructor's
          prototype property to assign properties and methods that should be
          shared. The combination constructor/prototype pattern uses the
          constructor to define instance properties and the prototype pattern to
          define shared properties and methods.

    Inheritance in JavaScript is implemented primarily using the concept of
    prototype chaining.  Prototype chaining involves assigning a constructor's
    prototype to be an instance of another type.  In doing so, the subtype
    assumes all of the properties and methods of the supertype in a manner
    similar to class-based inheritance. The problem with prototype chaining is
    that all of the inherited properties and methods are shared among object
    instances, making it ill-suited for use on its own.  The constructor
    stealing pattern avoids these issues, calling the supertype's constructor
    from inside of the subtype's constructor. This allows each instance to have
    its own properties but forces the types to be defined using only the
    constructor pattern. The most popular pattern of inheritance is combination
    inheritance, which uses prototype chaining to inherit shared properties and
    methods and uses constructor stealing to inherit instance properties.

    There are also the following alternate inheritance patterns:

        - Prototypal inheritance implements inheritance without the need for
          predefined constructors, essentially performing a shallow clone
          operation on a given object. The result of the operation then may be
          augmented further.

        - Closely related is parasitic inheritance, which is a pattern for
          creating an object based on another object or some information,
          augmenting it, and returning it.  This pattern has also been
          repurposed for use with combination inheritance to remove the
          inefficiencies related to the number of times the supertype constructor
          is called.

        - Parasitic combination inheritance is considered the most efficient way
          to implement typebased inheritance.

================================================================================


                          CHAP  7: FUNCTION EXPRESSION
                          ----------------------------


    1. Function expression characteristics
    2. Recursion with functions
    3. Private variables using Closures
    4. Mimicking Block Scope (Anonymous Function)
    5. Private Variables
    6. Summary


    1. Function expression characteristics
    --------------------------------------

    There are two ways to define a function:
        - function declaration
        - function expression


    Function declaration, has the following form
    --------------------------------------------

        function functionName(arg1, arg2) {
            ...
        }

     One of the key characteristics of function declarations is function
     declaration hoisting, whereby function declarations are read before the
     code executes. That means a function declaration may appear after code that
     calls it and still work.

     Function expressions have several forms. The most common
     --------------------------------------------------------

        var functionName = function(arg1, arg2){
            ...
        };

    This pattern of function expression looks like a normal variable assignment.
    A function is created and assigned to the variable functionName. The created
    function is considered to be an anonymous function, because it has no
    identifier after the function keyword.  (Anonymous functions are also
    sometimes called lambda functions.) This means the name property is the
    empty string.

    Function expressions act like other expressions and, therefore, must be
    assigned before usage. The following causes an error:

        sayHi();                //error - function doesn't exist yet
        var sayHi = function(){
            alert("Hi!");
        };

    NOTE: Hoisting only works for normal function declaration.


    A very important property of functions is that the variables created inside
    of them, including their parameters, are local to the function.  This
    "localness" of variables applies only to the parameters and variables
    declared with the "var" keyword inside the function body. Variables declared
    outside of any function are called global, because they are visible
    throughout the program. It is possible to access such variables from inside
    a function, as long as you haven't declared a local variable with the same
    name.

    2. Recursion with functions
    ---------------------------

    A recursive function typically is formed when a function calls itself by
    name, as in the following example:

    Ex.

        function factorial(num){
            if (num <= 1){
            return 1;
            } else {
                return num * factorial(num-1);
            }
        }

    3. Private variables using Closures
    -----------------------------------

    ** Closures' Rules and Side Effects **
    ** Closures and Variables **
    ** The "this" Object **

    The terms anonymous functions and closures are often incorrectly used
    interchangeably.

    Closures are functions that have access to variables from another function's
    scope. This is often accomplished by creating a function inside a function.

    A closure is an inner function that has access to the outer (enclosing)
    function's variables-scope chain. The closure has three scope chains:

        - it has access to its own scope (variables defined between its curly
          brackets),
        - it has access to the outer function's variables,
        - it has access to the global variables.

    The details of how scope chains are created and used are important for a
    good understanding of closures. When a function is called, an execution
    context is created, and its scope chain is created. The activation object
    for the function is initialized with values for arguments and any named
    arguments. The outer function's activation object is the second object in
    the scope chain. This process continues for all containing functions until
    the scope chain terminates with the global execution context.

    The inner function has access not only to the outer function's variables,
    but also to the outer function's parameters. Note that the inner function
    cannot call the outer function's arguments object, however, even though it
    can call the outer function's parameters directly.

    Ex.

        function showName(first, last) {
            var intro = "Your name is ";

            function makeFullName() {
                return intro + first + last;
            }

            return makeFullName();
        }

        console.log(showName(' Gene', ' Ordanza II'));


    ** Closures' Rules and Side Effects **
    --------------------------------------

    1. Closures have access to the outer function's variable even after the
       outer function returns.

    2. Closures store references to the outer function's variables; they do not
       store the actual value. Closures get more interesting when the value of
       the outer function's variable changes before the closure is called.

    3. Closures Gone Awry.  Because closures have access to the updated values
       of the outer function's variables, they can also lead to bugs when the
       outer function's variable changes with a for loop.

    NOTE: Since closures carry with them the containing function's scope, they
          take up more memory than other functions. Overuse of closures can lead
          to excess memory consumption, so it's recommended you use them only
          when absolutely necessary.


    ** Closures and Variables **
    ----------------------------

    There is one notable side effect of this scope-chain configuration. The
    closure always gets the last value of any variable from the containing
    function. Remember that the closure stores a reference to the entire
    variable object, not just to a particular variable.

    Ex.

        function createFunctions(){
            var result = new Array();

            for (var i=0; i < 10; i++){
                result[i] = function(){
                    return i;
                };
            }

            return result;
        }

    This function returns an array of functions. It seems that each function
    should just return the value of its index, so the function in position 0
    returns 0, the function in position 1 returns 1, and so on.

    In reality, every function returns 10. Since each function has the
    createFunctions() activation object in its scope chain, they are all
    referring to the same variable, i.  When createFunctions() finishes running,
    the value of i is 10, and since every function references the same variable
    object in which i exists, the value of i inside each function is 10. You
    can, however, force the closures to act appropriately by creating another
    anonymous function,

    Ex.

        function createFunctions() {
            var result = new Array();

            for (var i=0; i < 10; i++) {
                result[i] = function(num) {
                    return function() {
                        return num;
                    };
                }(i);
            }
            return result;
        }

    With this version, each function returns a different number. Instead of
    assigning a closure directly into the array, an anonymous function is
    defined and called immediately.

    ** The "this" Object **
    -----------------------

    Using "this" object inside closures introduces some complex behaviors. The
    "this" object is bound at runtime based on the context in which a function
    is executed: when used inside global functions, this is equal to window in
    nonstrict mode and undefined in strict mode, whereas this is equal to the
    object when called as an object method. Anonymous functions are not bound to
    an object in this context, meaning the this object points to window unless
    executing in strict mode (where this is undefined). Because of the way
    closures are written, however, this fact is not always obvious.

    Remember that each function automatically gets two special variables as soon
    as the function is called: "this" and "arguments". An inner function can
    never access these variables directly from an outer function. It is possible
    to allow a closure access to a different this object by storing it in
    another variable that the closure can access.

    NOTE: The "this" keyword always refers to the inner function, if you have
          nested functions, you have to create another variable and point that
          to this.


    4. Mimicking Block Scope (Anonymous Function)
    ---------------------------------------------

    JavaScript has no concept of block-level scoping, meaning variables
    defined inside of block statements are actually created in the containing
    function, not within the statement.

    Anonymous functions can be used to mimic block scoping and avoid such
    problems. The basic syntax of an anonymous function used as a block scope
    (often called a private scope) is as follows:

    Ex.

        (function(){
            ...
        })();

    This syntax defines an anonymous function that is called immediately and is
    also sometimes called an immediately invoked function. What looks like a
    function declaration is enclosed in parentheses to indicate that it's
    actually a function expression. This function is then called via the second
    set of parentheses at the end.

    Any variables defined within the anonymous function are destroyed as soon
    as it completes execution.

    However, the following won't work:

        function(){
            //block code here
        }();                    //error!

    This code causes a syntax error, because JavaScript sees the function
    keyword as the beginning of a function declaration, and function
    declarations cannot be followed by parentheses. Function expressions,
    however, can be followed by parentheses. To turn the function declaration
    into a function expression, you need only surround it with parentheses.

        (function(){
            //block code here
        })();



    5. Private Variables
    --------------------

    ** Static Private Variable **
    ** The Module Pattern **
    ** The Module-Augmentation Pattern **

    Strictly speaking, JavaScript has no concept of private members; all object
    properties are public.  There is, however, a concept of private variables.
    Any variable defined inside a function is considered private since it is
    inaccessible outside that function. This includes function arguments, local
    variables, and functions defined inside other functions.

    Ex.

        function add(num1, num2){
            var sum = num1 + num2;
            return sum;
        }

    In this function, there are three private variables: num1, num2, and sum.
    These variables are accessible inside the function but can't be accessed
    outside it. If a closure were to be created inside this function, it would
    have access to these variables through its scope chain. Using this
    knowledge, you can create public methods that have access to private
    variables.  A privileged method is a public method that has access to
    private variables and/or private functions. There are two ways to create
    privileged methods on objects.

    The first is to do so inside a constructor,

    Ex.

        function MyObject() {

            //private variable and functions
            var privateVariable = 10;

            function privateFunction() {
                return false;
            }

            //privileged method
            this.publicMethod = function () {
                privateVariable++;
                return privateFunction();
            }
        }

    This pattern defines all private variables and functions inside the
    constructor. Then privileged methods can be created to access those private
    members. This works because the privileged methods, when defined in the
    constructor, become closures with full access to all variables and functions
    defined inside the constructor's scope.  Once an instance of MyObject is
    created, there is no way to access privateVariable and privateFunction()
    directly; you can do so only by way of publicMethod().

    You can define private and privileged members to hide data that should not
    be changed directly.

    Ex.

        function Person(name) {
            this.getName = function() {
                return name;
            };

            this.setName = function(value) {
                name = value;
            };
        }

        var person = new Person('Nicholas');
        alert(person.getName());    //Nicholas
        person.setName('Greg');
        alert(person.getName());    //Greg


    The constructor in this code defines two privileged methods: getName() and
    setName(). Each method is accessible outside the constructor and accesses
    the private name variable. Outside the Person constructor, there is no way
    to access name. Since both methods are defined inside the constructor, they
    are closures and have access to name through the scope chain. The private
    variable name is unique to each instance of Person since the methods are
    being re-created each time the constructor is called. One downside, however,
    is that you must use the constructor pattern to accomplish this result.
    However, constructor pattern is flawed in that new methods are created for
    each instance. Using static private variables to achieve privileged methods
    avoids this problem.


    ** Static Private Variable **
    -----------------------------

    Privileged methods can also be created by using a private scope to define
    the private variables or functions.

    Ex.

        (function() {

            //private variables and functions
            var privateVariable = 10;

            function privateFunction() {
                return false;
            }

            //constructor
            MyObject = function() {
            };

            //public and privileged methods
            MyObject.prototype.publicMethod = function() {
                privateVariable++;
                return privateFunction();
            };
        })();


    In this pattern, a private scope is created to enclose the constructor and
    its methods. The private variables and functions are defined first, followed
    by the constructor and the public methods.  Public methods are defined on the
    prototype, as in the typical prototype pattern. Note that this pattern
    defines the constructor not by using a function declaration but instead by
    using a function expression. Function declarations always create local
    functions, which is undesirable in this case.  For this same reason, the
    "var" keyword is not used with MyObject. Remember: initializing an
    undeclared variable always creates a global variable, so MyObject becomes
    global and available outside the private scope. Also keep in mind that
    assigning to an undeclared variable in strict mode causes an error.

    The main difference between this pattern and the previous one is that
    private variables and functions are shared among instances. Since the
    privileged method is defined on the prototype, all instances use that same
    function. The privileged method, being a closure, always holds a reference
    to the containing scope.

    NOTE: The farther up the scope chain a variable lookup is, the slower the
          lookup becomes because of the use of closures and private variables.


    ** The Module Pattern **
    ------------------------

    The previous patterns create private variables and privileged methods for
    custom types. The module pattern, does the same for singletons.  Singletons
    are objects of which there will only ever be one instance. Traditionally,
    singletons are created in JavaScript using object literal notation.

        var singleton = {
            name : value,
            method : function() {
                ...
            }
        }

    The module pattern augments the basic singleton to allow for private
    variables and privileged methods, taking the following format:

    Ex.

        var singleton = function() {

            //private variables and functions
            var privateVariable = 10;

            function privateFunction() {
                return false;
            }

            //privileged/public methods and properties
            return {
                publicProperty : true,

                publicMethod   : function() {
                    privateVariable++;
                    return privateFunction();
                }
            };
        }();


    The module pattern uses an anonymous function that returns an object. Inside
    of the anonymous function, the private variables and functions are defined
    first. After that, an object literal is returned as the function value. That
    object literal contains only properties and methods that should be public.
    Since the object is defined inside the anonymous function, all of the public
    methods have access to the private variables and functions. Essentially, the
    object literal defines the public interface for the singleton. This can be
    useful when the singleton requires some sort of initialization and access to
    private variables, as in this example:

        var application = function() {

            //private variables and functions
            var components = new Array();

            //initialization
            component.push(new BaseComponent());

            //public interface
            return {
                getComponentCount : function() {
                    return components.length;
                },

                registerComponent : function(component) {
                    if (typeof component == 'object') {
                        components.push(component);
                    }
                }
            };
        }();

    In web applications, it's quite common to have a singleton that manages
    application-level information. This simple example creates an application
    object that manages components.  When the object is first created, the
    private components array is created and a new instance of BaseComponent is
    added to its list. (The code for BaseComponent is not important; it is used
    only to show initialization in the example.) The getComponentCount() and
    registerComponent() methods are privileged methods with access to the
    components array. The former simply returns the number of registered
    components, and the latter registers a new component.

    The module pattern is useful for cases like this, when a single object must
    be created and initialized with some data and expose public methods that
    have access to private data. Every singleton created in this manner is an
    instance of Object, since ultimately an object literal represents it. This
    is inconsequential, because singletons are typically accessed globally
    instead of passed as arguments into a function, which negates the need to
    use the instanceof operator to determine the object type.



    ** The Module-Augmentation Pattern **
    -------------------------------------

    Another take on the module pattern calls for the augmentation of the object
    before returning it. This pattern is useful when the singleton object needs
    to be an instance of a particular type but must be augmented with additional
    properties and/or methods. Consider the following example:

    Ex.

        var singleton = function() {

            //private variables and functions
            var privateVariable = 10;

            function privateFunction() {
                return false;
            }

            //crate object
            var object = new CustomType();

            //add privileged/public properties and methods
            object.publicProperty = true;

            object.publicMethod = function() {
                privateVariable++;
                return privateFunction();
            };

            //return the object
            return object;
        }();

    If the application object in the module pattern example had to be an
    instance of BaseComponent, the following code could be used:

    Ex.

        var application = function(){

            //private variables and functions
            var components = new Array();

            //initialization
            components.push(new BaseComponent());

            //create a local copy of application
            var app = new BaseComponent();

            //public interface
            app.getComponentCount = function(){
                return components.length;
            };

            app.registerComponent = function(component){
                if (typeof component == .object.){
                    components.push(component);
                }
            };

            //return it
            return app;
        }();

    The main difference is the creation of a variable named app that is a new
    instance of BaseComponent. This is the local version of what will become the
    application object. Public methods are then added onto the app object to
    access the private variables.  The last step is to return the app object,
    which assigns it to application.


    6. Summary
    ----------

    Function expressions are useful tools in JavaScript programming. They allow
    truly dynamic programming where functions need not be named. These anonymous
    functions, also called lambda functions, are a powerful way to use
    JavaScript functions. The following is a summary of function expressions:

        - Function expressions are different from function declarations.
          Function declarations require names, while function expressions do
          not. A function expression without a name is also called an anonymous
          function.

        - With no definitive way to reference a function, recursive functions
          become more complicated.

        - Recursive functions running in nonstrict mode may use arguments.callee
          to call themselves recursively instead of using the function name,
          which may change.

    Closures are created when functions are defined inside other functions,
    allowing the closure access to all of the variables inside of the
    containing function, as follows:

        - Behind the scenes, the closure's scope chain contains a variable
          object for itself, the containing function, and the global context.

        - Typically a function's scope and all of its variables are destroyed
          when the function has finished executing.

        - When a closure is returned from that function, its scope remains in
          memory until the closure no longer exists.

    Using closures, it's possible to mimic block scoping in JavaScript, which
    doesn't exist natively, as follows:

        - A function can be created and called immediately, executing the code
          within it but never leaving a reference to the function.

        - This results in all of the variables inside the function being
          destroyed unless they are specifically set to a variable in the
          containing scope.

    Closures can also be used to create private variables in objects, as
    follows:

        - Even though JavaScript doesn't have a formal concept of private object
          properties, closures can be used to implement public methods that have
          access to variables defined within the containing scope.

        - Public methods that have access to private variables are called
          privileged methods.

        - Privileged methods can be implemented on custom types using the
          constructor or prototype patterns and on singletons by using the
          module or module-augmentation patterns.

    Function expressions and closures are extremely powerful in JavaScript and
    can be used to accomplish many things. Keep in mind that closures maintain
    extra scopes in memory, so overusing them may result in increased memory
    consumption.

================================================================================


                CHAP 10: THE DOCUMENT OBJECT MODEL (DOM Level 1)
                ------------------------------------------------


    1. Understanding the DOM as a hierarchy of nodes
    2. Working with the various node types
    3. Coding the DOM around browser incompatibilities and gotchas

    The Document Object Model (DOM) is an application programming interface
    (API) for HTML and XML documents. The DOM represents a document as a
    hierarchical tree of nodes, allowing developers to add, remove, and modify
    individual parts of the page. It evolve out of early Dynamic HTML (DHTML)
    innovations from Netscape and Microsoft.


    1. Understanding the DOM as a hierarchy of nodes
    ------------------------------------------------

    ** There are several Node Type **
    ** Other Node Properties **
    ** Node Relationship **
    ** Common Node Properties **
    ** Manipulating Nodes **


    In the HTML DOM (Document Object Model), everything is a node:

    - The document itself is a document node
    - All HTML elements are element nodes
    - All HTML attributes are attribute nodes
    - Text inside HTML elements are text nodes
    - Comments are comment nodes

    When an HTML document is loaded into a web browser, it becomes a 'document'
    object.

    The document object is the root node of the HTML document and the "owner" of
    all other nodes: (element nodes, text nodes, attribute nodes, and comment
    nodes).

    The document object provides properties and methods to access all node
    objects, from within JavaScript.  The document is a part of the window
    object and can be accessed as "window.document".


    The Document Object Model (DOM) is an application programming interface
    (API) for HTML and XML documents. The DOM represents a document as a
    hierarchical tree of nodes, allowing developers to add, remove, and modify
    individual parts of the page.  Any HTML or XML document can be represented
    as a hierarchy of nodes using the DOM.

    DOM Level 1 describes an interface called Node that is to be implemented by
    all node types in the DOM. The Node interface is implemented in JavaScript
    as the Node type, which is accessible in all browsers except IE. All node
    types inherit from Node in JavaScript, so all node types share the same
    basic properties and methods.

    Every node has a nodeType property that indicates the type of node that it
    is. Node types are represented by one of the following 12 numeric constants
    on the Node type.


    ** There are several Node Type **
    ---------------------------------

    - Node.ELEMENT_NODE         (1)
    - Node.ATTRIBUTE_NODE       (2)
    - Node.TEXT_NODE            (3)
    - Node.CDATA_SECTION_NODE   (4)
    - Node.ENTITY_REFERENCE_NODE(5)
    - Node.ENTITY_NODE          (6)
    - Node.PROCESSING_INSTRUCTION_NODE (7)
    - Node.COMMENT_NODE         (8)
    - Node.DOCUMENT_NODE        (9)
    - Node.DOCUMENT_TYPE_NODE   (10)
    - Node.DOCUMENT_FRAGMENT_NODE (11)
    - Node.NOTATION_NODE        (12)

    A node's type is easy to determine by comparing against one of these
    constants but for cross-browser compatibility, it's best to compare the
    nodeType property against a numeric value.

    Ex.
        if (someNode.nodeType == 1) {
            console.log("Node is an element!");
        }


    ** Other Node Properties **
    ---------------------------

    - nodeName
    - nodeValue

    These two properties give specific information about the node. The values of
    these properties are completely dependent on the node type. It's always best
    to test the node type before using one of these values, as the following
    code shows:

    Ex.

        if (someNode.nodeType == 1) {
            value = someNode.nodeName;      // will be the element's tag name
        }


    ** Common Node Properties **
    ----------------------------
    - element.nodeType
    - element.parentNode
    - element.childNodes
    - element.nextSibling
    - element.previousSibling


    ** Node Relationship **
    -----------------------

    All nodes in a document have relationships to other nodes. In HTML,
    the <body> element is considered a child of the <html> element; likewise the
    <html> element is considered the parent of the <body> element. The <head>
    element is considered a sibling of the <body> element, because they both
    share the same immediate parent, the <html> element.

    Each node has a 'childNodes' property containing a NodeList. A 'NodeList' is
    an array-like object used to store an ordered list of nodes that are
    accessible by position. Keep in mind that a NodeList is not an instance of
    Array.

    Ex.

        var firstChild  = someNode.childNodes[0];
        var secondChild = someNode.childNodes.item(1);
        var count       = someNode.childNodes.length;

    Note that using bracket notation and using the item() method are both
    acceptable practices. Also note that the 'length' property indicates the
    number of nodes in the NodeList at that time.

    Each node has a 'parentNode' property pointing to its parent in the document
    tree. Additionally, each node within a childNodes list is considered to be
    a sibling of the other nodes in the same list. It's possible to navigate
    from one node in the list to another by using the 'previousSibling' and
    'nextSibling' properties. If there's only one child node, both 'nextSibling'
    and 'previousSibling' will be null.

    One final relationship is shared by every node. The 'ownerDocument' property
    is a pointer to the document node that represents the entire document. Nodes
    are considered to be owned by the document in which they were created
    because nodes cannot exist simultaneously in two or more documents. This
    property provides a quick way to access the document node without needing to
    traverse the node hierarchy back up to the top.


    ** Manipulating Nodes **
    ------------------------

    appendChild() - Adds a new child node, to an element, as the last child node

    Ex.
        var returnedNode = someNode.appendChild(newNode);
        console.log(returnedNode == newNode);               // true
        console.log(someNode.lastChild == newNode);         // true

    If the node passed into appendChild() is already part of the document, it is
    removed from its previous location and placed at the new location. Even
    though the DOM tree is connected by a series of pointers, no DOM node may
    exist in more than one location in a document.


    insertBefore() - Inserts new node before a specified, existing, child node.

    Ex.
        // insert as last child
        returnedNode = someNode.insertBefore(newNode, null);
        console.log(newNode == someNode.lastChild)

        // insert as first child
        returnedNode = someNode.insertBefore(newNode, someNode.firstChild)
        console.log(newNode == someNode.firstChild)


    replaceChild() - Replaces a child node in an element

    Ex.
        var returnedNode = someNode.replaceChild(newNode, someNode.firstChild);


--------------------------------------------------------------------------------

    2. Working with the various node types
    --------------------------------------

    ** The Document Type **
    ** The HTML Element Type **
    ** Text Node and Creating Text Node **

    ** The Document Type **
    -----------------------

    + Characteristic of Document Node
    + Document Children
    + Retrieve Elements
    + Document Writing

    JavaScript represents document nodes via the 'Document' type. In browsers,
    document object is an instance of HTMLDocument (which inherit from Document)
    and represents the entire HTML page. The document object is a property of
    window and so is accessible globally.

    + Characteristic of Docment Node
    --------------------------------

    - nodeType is 9.
    - nodeName is .#document..
    - nodeValue is null.
    - parentNode is null.
    - ownerDocument is null.
    - Child nodes may be a DocumentType (maximum of one), Element (maximum of
      one), ProcessingInstruction, or Comment.

    The Document type can represent HTML pages or other XML-based documents.


    + Document Children
    -------------------

    Though the DOM specification states that the children of a Document node
    can be a DocumentType, Element, etc. There are two built-in shortcuts to
    child nodes.

    'documentElement' property, which always points to the <html> element in an
    HTML page.

    Ex.

        <html>
            <body>
            </body>
        </html>

    When this page is parsed by a browser, the document has only one child node,
    which is the <html> element. This element is accessible from both
    'documentElement' and the 'childNodes' list.

    Ex.
        var html = document.documentElement;    // reference to <html> element
        alert(html == document.childNodes[0]);  // true
        alert(html == document.firstChild);     // true

        var body  = document.body;              // reference to <body> element
        var title = document.title;             // reference to document title
        document.title = "New Page Title";      // set the document title.
        var url   = document.URL;               // get complete URL
        var domain   = document.domain;         // get the domain
        var referrer = document.referrer;       // get the referrer


    + Retrieve Elements
    -------------------

    document.getElementById() - Returns the element that has the ID attribute
                                with the specified value.

    document.getElementsByName() - Accesses all elements with a specified name

    document.getElementsByTagName() Returns a NodeList containing all elements
                                with the specified tagname.

    Ex.
        <div id="myDiv">Some text</div>
        var div = document.getElementById("myDiv");

        var images = document.getElementsByTagName("img");
        alert(images.length);       // number of images
        alert(images[0].src);       // output the src attribute of first image
        alert(images.item(0).src);  // output the src attribute of first image

        var allElements = document.getElementsByTagName("*"); // all elements


        <fieldset>
            <legend>What color do you prefer?<legend>
            <ul>
              <li><input type="radio" value="red"></li>
              <li><input type="radio" value="greenn"></li>
              <li><input type="radio" value="blue"></li>
            </ul>
        </fieldset>

        var radios = document.getElementsByName("color");


    + Document Writing
    ------------------

    One of the older capabilities of the document object is the ability to write
    to the output stream of a web page. This capability comes in the form of
    four methods:

        write(), writeln(), open(), and close().

    These are no longer in use to too often. The write() and writeln() methods
    are often used to dynamically include external resources such as JavaScript
    files.

    <body>
        <script type="text/javascript">
          document.write("<script type=\"text/javascript\" src=\"file.js\">" +
                         "<\/script>");
        </script>
    </body>


--------------------------------------------------------------------------------

    ** The HTML Element Type **
    ---------------------------

    + Standard Attributes for HTML element
    + Getting Attributes
    + Setting Attributes
    + Removing Attributes
    + Creating Elements

    Next to the Document type, the Element type is most often used in web
    programming. The Element type represents an XML or HTML element,
    providing access to information such as its tag name, children, and
    attributes.

    An element's tag name is accessed via the 'nodeName' property or by using
    the 'tagName' property; both properties return the same value (the latter is
    typically used for clarity).

    Ex.
        <div id="myDiv"></div>

        var div = document.getElementById("myDiv");
        alert(div.tagName);     // "DIV"
        alert(div.tagname == div.nodeName);     // true


    + Standard Attributes for HTML element
    --------------------------------------

    - id > A unique identifi er for the element in the document.
    - title > Additional information about the element, typically represented as a
              tooltip.
    - lang > The language code for the contents of the element (rarely used).
    - dir  > The direction of the language, "ltr" (left-to-right) or "rtl"
             (right-to-left); also rarely used.
    - className > The equivalent of the class attribute, which is used to specify
             CSS classes on an element.


    + Getting Attributes
    --------------------

    Ex.
        var div = document.getElementById("myDiv");
        alert(div.getAttribute("id");
        alert(div.getAttribute("class");
        alert(div.getAttribute("title");

    NOTE: Because of behaviour differences, developers tend to forego
          getAttribute() when programming the DOM in JavaScript and instead use
          the object properties exclusively. The getAttribute() method
          is used primarily to retrieve the value of a custom attribute.


    + Setting Attributes
    --------------------

    Ex.
        div.setAttributes("id", "anotherID");
        div.setAttributes("class", "ft");

    Because all attributes are properties, assigning directly to the property
    can set the attribute values.

        div.id    = "anotherID";
        div.align = "left";


    + Removing Attributes
    ---------------------

    removeAttribute() -



    + Creating Elements
    -------------------

    Ex.

        var div = document.createElement('div');
        div.id  = 'myNewDiv';
        div.className = 'box';

    Setting these attributes on the new element assigns information only. Since
    the element isn't part of the document tree, it doesn't affect the browser's
    display. The element can be added to the document tree using appendChild(),
    insertBefore(), or replaceChild(). The following code adds the newly created
    element to the document.s <body> element:

    Ex.

        document.body.appendChild('div');

    Once the element has been added to the document tree, the browser renders it
    immediately. Any changes to the element after this point are immediately
    reflected by the browser.


    ** Text Node and Creating Text Node **
    --------------------------------------

    'Text' nodes are represented by the Text type and contain plain text that is
    interpreted literally and may contain escaped HTML characters but no HTML
    code. A 'Text' node has the following characteristics:

    - nodeType is 3.
    - nodeName is "#text".
    - nodeValue is text contained in the node.
    - parentNode is an Element.
    - Child nodes are not supported.

    Ex.
        var textNode = document.createTextNode("<strong>Hello</strong> world!");

        var element = document.createElement('div');
        element.className = "message";

        var textNode = document.createTextNode('Hello world!");
        element.appendChild(textNode);

        document.body.appendChild(element);


    3. Coding the DOM around browser incompatibilities and gotchas
    --------------------------------------------------------------

    ** Working With DOM **
    ----------------------

    Dynamic Scripts are those that don't exist when the page is loaded but are
                    included later by using the DOM. As with the HTML element,
    there are two ways to do this: pulling in an external file or insert text
    directly.

    Ex. Loading External JavaScript file

        <script type="text/javascript" scr="client.js"></script>

    Equivalent to the following code:

        function loadScript(url) {
            var script  = document.createElement('script');
            script.type = "text/javascript"
            script.src  = url;
            document.body.appendChild(script);
        }

    Ex. Loading Dynamic Styles

        <link rel="stylesheet" type="text/css" href="styles.css">

    Equivalent to the following code:

        function loadStyle(url) {
            var link  = document.createElement("link");
            link.rel  = "stylesheet";
            link.type = "text/css";
            link.href = url
            var head = document.getElementsByName("head")[0];
            head.appendChild(link);
        }

================================================================================


                                CHAP 13: EVENTS
                                ---------------


    1. Event Flow
    2. Event Handler
    3. The Event Object
    4. Event Types
    5. Memory and Performance
    6. Simulating Events
    7. Summary


    JavaScript's interaction with HTML is handled through events, which indicate
    when particular moments of interest occur in the document or browser window.
    Events can be subscribed to using listeners (also called handlers) that
    execute only when an event occurs. This model, called the observer pattern
    in traditional software engineering, allows a loose coupling between the
    behavior of a page (defined in JavaScript) and the appearance of the page
    (defined in HTML and CSS).

    DOM Level 2 was the first attempt to standardize the DOM events API in a
    logical way.

    The browser event system is a complex one. Even though all major browsers
    have implemented DOM Level 2 Events, the specification doesn't cover all
    event types. The BOM also supports events, and the relationship between
    these and the DOM events is often confusing.


    1. Event Flow
    -------------

    ** Event Flow - Event Bubbling **
    ** Event Flow - Event Capturing **
    ** DOM Event Flow **

    Event flow describes the order in which events are received on the page.
    To understand the issue, consider a series of concentric circles on a piece
    of paper. When you place your finger at the center, it is inside of not just
    one circle but all of the circles on the paper. When you click on a button,
    they concluded, you're clicking not just on the button but also on its
    container and on the page as a whole.

    Internet Explorer (IE) would support an EVENT BUBBLING flow, whereas Netscape
    Communicator would support an EVENT CAPTURING flow.

    ** Event Flow - Event Bubbling **
    ---------------------------------

    The Internet Explorer event flow is called event bubbling, because an event
    is said to start at the most specific element (the deepest possible point
    in the document tree) and then flow upward toward the least specific node
    (the document).

    NOTE:  All modern browsers support event bubbling, although there are some
           variations on how it is implemented.

    Ex.

        <!DOCTYPE>
        <html>
        <head>
            <title>Event Bubbling Example<title>
        </head>

        <body>
            <div id='myDiv'>Click Me <div>
        </body>
        </html>


    When you click the <div> element in the page, the click event occurs in the
    following order:

        1. <div>
        2. <body>
        3. <html>
        4. document

    The click event is first fired on the <div>, which is the element that was
    clicked. Then the click event goes up the DOM tree, firing on each node
    along its way until it reaches the document object.


    ** Event Flow - Event Capturing **
    ----------------------------------

    The theory of event capturing is that the least specific node should receive
    the event first and the most specific node should receive the event last.
    Event capturing was really designed to intercept the event before it reached
    the intended target.


    IMPORTANT: Event capturing is generally not used because of a lack of
               support in older browsers. The general advice is to use event
               bubbling freely while retaining event capturing for special
               circumstances.


    ** DOM Event Flow **
    --------------------

    The event flow specified by DOM Level 2 Events has three phases:
        - the event capturing phase
        - at the target
        - the event bubbling phase.

    Event capturing occurs first, providing the opportunity to intercept events
    if necessary. Next, the actual target receives the event.  The final phase
    is bubbling, which allows a final response to the event.

    Considering the simple HTML in the (** Event Flow - Event Bubbling **),
    clicking the <div> fires the event in the following order:

    (1) Document -> (2) Element (html) -> (3) Element (body) -> (4) Element(div)
    (5) Element (body) -> (6) Element (html) -> (7) Document


    In the DOM event flow, the actual target (the <div> element) does not receive
    the event during the capturing phase. This means that the capturing phase
    moves from document to <html> to <body> and stops. The next phase is
    "at target," which fires on the <div> and is considered to be part of the
    bubbling phase in terms of event handling (discussed later). Then, the
    bubbling phase occurs and the event travels back up to the document.


    2. Event Handler
    ----------------

    ** HTML Event Handlers **
    ** DOM Level 0 Event Handlers **
    ** DOM Level 2 Event Handlers **
    ** Cross-Browser Event Handlers **


    Events are certain actions performed either by the user or by the browser
    itself. These events have names like click, load, and mouseover. A function
    that is called in response to an event is called an event handler (or an
    event listener). Event handlers have names beginning with "on", so an event
    handler for the 'click' event is called 'onclick. and an event handler for
    the 'load' event is called 'onload'.

    ** HTML Event Handlers **
    -------------------------

    Each event supported by a particular element can be assigned using an HTML
    attribute with the name of the event handler. The value of the attribute
    should be some JavaScript code to execute.

    Ex.

        <input type="button" value="click me" onclick="alert('Clicked')" />
        <input type="button" value="click me" onclick="some-js-func()" />

    When this button is clicked, an alert is displayed. This interaction is
    defined by specifying the onclick attribute and assigning some JavaScript
    code as the value. Note that since the JavaScript code is an attribute
    value, you cannot use HTML syntax characters such as the ampersand, double
    quotes, less-than, or greater-than without escaping them. In this case,
    single quotes were used instead of double quotes to avoid the need to use
    HTML entities.

    There are a few downsides to assigning event handlers in HTML. The first is
    a timing issue: it's possible that the HTML element appears on the page and
    is interacted with by the user before the event handler code is ready.

    Another downside is that the scope chain augmentation in the event handler
    function can lead to different results in different browsers.

    The last downside to assigning event handlers using HTML is that it tightly
    couples the HTML to the JavaScript. If the event handler needs to be
    changed, you may need to change code in two places:  HTML and in JavaScript.
    This is the primary reason that many developers avoid HTML event handlers in
    favor of using JavaScript to assign event handlers.


    ** DOM Level 0 Event Handlers **
    --------------------------------

    The traditional way of assigning event handlers in JavaScript is to assign a
    function to an event handler property. To assign an event handler using
    JavaScript, you must first retrieve a reference to the object to act on.

    An event handler is assigned by setting the property equal to a
    function, as in this example:

    Ex.

        var btn = document.getElementById("myBtn");
        btn.onclick = function() {
            alert('Clicked');
        };

    Here, a button is retrieved from the document and an "onclick" event handler
    is assigned. Note that the event handler isn't assigned until this code is
    run, so if the code appears after the code for the button in the page, there
    may be an amount of time during which the button will do nothing when
    clicked.


    ** DOM Level 2 Event Handlers **
    --------------------------------

    DOM Level 2 Events define two methods to deal with the assignment and
    removal of event handlers:
        - addEventListener()
        - removeEventListener()

    These methods exist on all DOM nodes and accept three arguments:
        - the event name to handle
        - the event handler function
        - Boolean value indicating whether to call the event handler during the
          capture phase (true) or during the bubble phase (false).

    Ex.

        var btn = document.getElementById("myBtn");
        btn.addEventListener("click", function() {
                                alert(this.id);
                            }, false);

        btn.addEventListener("click", ..., false);

    This code adds an onclick event handler to a button that will be fired in
    the bubbling phase (since the last argument is false). As with the DOM
    Level 0 approach, the event handler runs in the scope of the element on
    which it is attached. The major advantage to using the DOM Level 2 method
    for adding event handlers is that multiple event handlers can be added.

    Event handlers added via addEventListener() can be removed only by using
    removeEventListener() and passing in the same arguments as were used when
    the handler was added. This means that anonymous functions added using
    addEventListener() cannot be removed.

    Ex.
        var btn = document.getElementById("myBtn");
        var handler = function() {
                        alert(this.id);
                      };

        btn.addEventListener("click", handler, false);
        btn.removeEventListener("click", handler, false);

    In most cases, event handlers are added to the bubbling phase of the event
    flow since this offers the broadest possible cross-browser support.
    Attaching an event handler in the capture phase is best done if you need to
    intercept events before they reach their intended target. If this is not
    necessary, it's advisable to avoid event capturing.


    ** Cross-Browser Event Handlers **

    To accommodate event handling in a cross-browser way, writing your own code
    is fairly straightforward, because it relies on capability detection.

    The first method to create is called addHandler(), and its job is to use
    the DOM Level 0 approach, the DOM Level 2 approach, or the Internet Explorer
    approach to adding events, depending on which is available.

    Ex.

        var EventUtil = {

            addHandler: function (element, type, handler) {
                if (element.addEventListener) {
                    element.addEventListener(type, handler, false);
                } else if (element.attachEvent) {
                    element.attachEvent("on" + type, handler);
                } else {
                    element["on" + type] = handler;
                }
            },

            removeHandler: function (element, type, handler) {
                if (element.removeEventListener) {
                    element.removeEventListener(type, handler, false);
                } else if (element.detachEvent) {
                    element.detachEvent("on" + type, handler);
                } else {
                    element["on" + type] = null;
                }
            }
        };

    Both methods first check for the existence of the DOM Level 2 method on the
    element that was passed in. If the DOM Level 2 method exists, it is used,
    passing in the event type and the event handler function, along with a third
    argument of false (to indicate the bubbling phase).


    3. The Event Object
    -------------------

    ** DOM Event Object **

    When an event related to the DOM is fired, all of the relevant information
    is gathered and stored on an object called "event". This object contains
    basic information such as the element that caused the event, the type of
    event that occurred, and any other data that may be relevant to the
    particular event. For example, an event caused by a mouse action generates
    information about the mouse's position, whereas an event caused by keyboard
    action generates information about the keys that were pressed. All browsers
    support the event object, though not in the same way.

    ** DOM Event Object **
    ----------------------

    In DOM-compliant browsers, the "event" object is passed in as the sole
    argument to an event handler. Regardless of the method used to assign the
    event handler, DOM Level 0 or DOM Level 2, the event object is passed in.

    Ex.

        var btn = document.getElementById("myBtn");
        btn.onclick = function(event) {
            alert(event.type);
        };

        btn.addEventListener('click', function(event) {
            alert(event.type);
        }, false);

    When an event handler is assigned using HTML attributes, the event object is
    available as a variable called event.

    Ex.
        <input type="button" value="click me" onclick="alert(event.type)">

    The event object contains properties and methods related to the specific
    event that caused its creation. The available properties and methods differ
    based on the type of event that was fired, but all events have the members
    listed in the Event table (found in the Glosary section).

    Inside an event handler, the "this" object is always equal to the value of
    'currentTarget', whereas target contains only the actual target of the
    event. If the event handler is assigned directly onto the intended target,
    then 'this', 'currentTarget', and 'target' all have the same value.

    Ex.
        var brn = document.getElementById("myBtn");
        btn.onclick = function(event) {
            alert(event.currentTarget === this);    //true
            alert(event.target === this);           //true
        }

    The "type" property is useful when you want to assign a single function to
    handle multiple events.

    Ex.

        var btn = document.getElementById("myBtn");
        var handler = function(event) {
            switch(event.type) {
                case "click" :
                    alert("Clicked!");
                    break;

                case "mouse" :
                    event.target.style.backgroundColor = "red";
                    break;

                case "mouseout" :
                    event.target.style.backgroundColor = "";
                    break;
            }
        };

        btn.onclick     = handler;
        btn.onmouseover = handler;
        btn.onmouseout  = handler;


    The preventDefault() method is used to prevent the default action of a
    particular event. The default behavior of a link, for example, is to
    navigate to the URL specified in its href attribute when clicked. If you
    want to prevent that navigation from occurring, an onclick event handler
    can cancel that behavior,

    Ex.

        var link = document.getElementById("myLink");
        link.onclick = function(event) {
            event.preventDefault();
        };

    The stopPropagation() method stops the flow of an event through the DOM
    structure immediately, canceling any further event capturing or bubbling
    before it occurs. For example, an event handler added directly to a button
    can call stopPropagation() to prevent an event handler on document.body from
    being fired.

    4. Event Types
    --------------

    ** UI Events **
    ** Focus Events **
    ** Mouse and Wheel Events **
    ** Keyboard and Text Events **
    ** Composition Events **

    There are numerous categories of events that can occur in a web browser. As
    mentioned previously, the type of event being fired determines the
    information that is available about the event. DOM Level 3 Events specifies
    the following event groups:

        - User interface (UI) events are general browser events that may have
          some interaction with the BOM.
        - Focus events are fired when an element gains or loses focus.
        - Mouse events are fired when the mouse is used to perform an action on
          the page.
        - Wheel events are fired when a mouse wheel (or similar device) is used.
        - Text events are fired when text is input into the document.
        - Keyboard events are fired when the keyboard is used to perform an
          action on the page.
        - Composition events are fired when inputting characters for an Input
          Method Editor (IME).
        - Mutation events are fired when a change occurs to the underlying DOM
          structure.
        - Mutation name events, These events are deprecated and not implemented
          by any browser

    In addition to these categories, HTML5 defines another set of events, and
    browsers often implement proprietary events both on the DOM and on the BOM.

    DOM Level 3 Events redefines the event groupings from DOM Level 2 Events
    and adds additional event definitions. All major browsers support DOM
    Level 2 Events.

    ** UI Events **
    ---------------

    UI events are those events that aren't necessarily related to user actions.
    These events existed in some form or another prior to the DOM specification
    and were retained for backwards compatibility.

        - DOMActivate, Fires when an element has been activated by some user
          action, by either mouse or keyboard

        - load, Fires on a window when the page has been completely loaded
        - unload, Fires on a window when the page has been completely unloaded
        - abort, Fires on an <object> element if it is not fully loaded before
          the user stops the download process.
        - error, Fires on a window when a JavaScript error occurs.
        - select, Fires when the user selects one or more characters in a text
          box.
        - resize, Fires on a window or frame when it is resized.
        - scroll, Fires on element with a scrollbar when the user scrolls it.

    Most of the HTML events are related either to the window object or to form
    controls.

    The load Event - The load event is perhaps the most often used event in
    ^^^^^^^^^^^^^^   JavaScript. For the window object, the load event fires
    when the entire page has been loaded, including all external resources such
    as images.

    Generally speaking, any events that occur on the window can be assigned via
    attributes on the <body> element, because there is no access to the window
    element in HTML.  This really is a hack for backwards compatibility but is
    still well-supported in all browsers. It is recommended that you use the
    JavaScript approach whenever possible.

    Ex.
        EventUtil.addHandler(window, "load", function(event) {
            alert("Loaded");
        });


    The unload Event - A companion to the load event, the unload event fires
    ----------------   when a document has completely unloaded.  The unload
    event typically fires when navigating from one page to another and is most
    often used to clean up references to avoid memory leaks.

    Similar to the load event, an onunload event handler can be assigned in two
    ways. The first is by using JavaScript as shown here:

    Ex. JavaScript method

        EventUtil.addHandler(window, "unload", function(event) {
            alert("Unloaded!");
        });

    Ex. As attribute to <body> element:

        <html>
        <body onunload="alert('Unloaded!')">
        </body>
        </html>


    The resize Event - When the browser window is resized to a new height or
    ----------------   width, the resize event fires. This event fires on
    window, so an event handler can be assigned.


    ** Focus Events **
    ------------------

    Focus events are fired when elements of a page receive or lose focus.
    These events work in concert with the document.hasFocus() and
    document.activeElement properties to give insight as to how the user is
    navigating the page. There are six focus events:

    The two primary events of this group are "focus" and "blur", both of which
    have been supported in browsers since the early days of JavaScript. One of
    the biggest issues with these events is that they don't bubble.


    ** Mouse and Wheel Events **
    ----------------------------

    Mouse events are the most commonly used group of events on the Web, because
    the mouse is the primary navigation device used. There are nine mouse
    events defined in DOM Level 3 Events.

        - click, Fires when the user clicks the primary mouse button (typically
          the left button) or when the user presses the Enter key. This is an
          important fact for accessibility purposes, because onclick event
          handlers can be executed using the keyboard and the mouse.

        - dblclick, Fires when the user double-clicks the primary mouse button
          (typically the left button).

        - mousedown, Fires when the user pushes any mouse button down. This
          event cannot be fired via the keyboard.

        - mouseenter, Fires when the mouse cursor is outside of an element and
          then the user first moves it inside of the boundaries of the element.

        - mouseleave, Fires when the mouse cursor is over an element and then
          the user moves it outside of that element's boundaries

        - mousemove, Fires repeatedly as the cursor is being moved around an
          element. This event cannot be fired via the keyboard.

        - mouseout, Fires when the mouse cursor is over an element and then the
          user moves it over another element.

        - mouseover, Fires when the mouse cursor is outside of an element and
          then the user first moves it inside of the boundaries of the element.

        - mouseup, Fires when the user releases a mouse button.


    ** Keyboard and Text Events **
    ------------------------------

    Keyboard events are fired when the user interacts with the keyboard. DOM
    Level 2 Events originally specified keyboard events, but that section was
    removed before the specification became final. As a result, keyboard events
    are largely supported based on the original DOM Level 0 implementations.

    DOM Level 3 Events provides a specifi cation for keyboard events. There are
    three keyboard events, as described here:

    - keydown, Fires when the user presses a key on the keyboard and fires
      repeatedly while the key is being held down.

    - keypress, DOM Level 3 Events deprecates the keypress event in favor of
      the textInput event.

    - keyup, Fires when the user releases a key on the keyboard.

    These events are most easily seen as the user types in a text box, though
    all elements support them.  There is only one text event and it is called
    "textInput". This event is an augmentation of keypress intended to make it
    easier to intercept text input before being displayed to the user. The
    textInput event fires just before text is inserted into a text box.


    ** Composition Events **
    ------------------------

    Composition events were first introduced in DOM Level 3 Events to handle
    complex input sequences typically found on IMEs. IMEs allow users to input
    characters not found on the physical keyboard. For example, those using a
    Latin keyboard can still enter Japanese characters into the computer. IMEs
    often require multiple keys to be pressed at once while resulting in only a
    single character being entered. Composition events help to detect and work
    with such input.


    ** Mutation Events **

    The DOM Level 2 mutation events provide notification when a part of the
    DOM has been changed.  Mutation events are designed to work with any XML or
    HTML DOM and are not specific to a particular language.

    ** HTML5 Events **

    The DOM specification doesn't cover all events that are supported by all
    browsers. Many browsers have implemented custom events for various purposes
    based on either user need or a specific use case.

    ** Device Events **

    With the introduction of smartphones and tablet devices came a new set of
    ways for users to interact with a browser. As such, a new class of events
    was invented. Device events allow you to determine how a device is being
    used.


    5. Memory and Performance
    -------------------------

    ** Event Delegation **
    ** Removing Event Handlers **

    Since event handlers provide the interaction on modern web applications,
    many developers mistakenly add a large number of them to the page. In
    JavaScript, the number of event handlers on the page directly relates to
    the overall performance of the page. This happens for a number of reasons.
    The first is that each function is an object and takes up memory; the more
    objects in memory, the slower the performance. Second, the amount of DOM
    access needed to assign all of the event handlers up front delays the
    interactivity of the entire page.

    There are a number of ways that you can improve performance by minding your
    use of event handlers.

    ** Event Delegation **
    ----------------------

    The solution to the "too many event handlers" issue is called event
    delegation. Event delegation takes advantage of event bubbling to assign a
    single event handler to manage all events of a particular type. The click
    event, for example, bubbles all the way up to the document level. This
    means that it's possible to assign one onclick event handler for an entire
    page instead of one for each clickable element.

    Ex.
        <ul id="myLinks">
            <li id="goSomewhere">Go somewhere</li>
            <li id="doSomething">Do something</li>
            <li id="sayHi">Say hi</li>
        </ul>

        ---

        var list = document.getElementById('myLinks');

        EventUtil.addHandler(list, 'click', function(event) {
            event = EventUtil.getEvent(event);
            var target = EventUtil.getTarget(event);

            switch(target.id) {
                case "doSomething":
                    document.title = "I change the document title";
                    break

                case "goSomewhere":
                    location.href = "http://www.wrox.com";
                    break;

                case "sayHi":
                    alert("hi");
                    break;
            }
        });


    In this code, event delegation is used to attach a single onclick event
    handler to the <ul> element.  Since all of the list items are children of
    this element, their events bubble up and are handled by this function. The
    event target is the list item that was clicked, so you can check the id
    property to determine the appropriate action.


    ** Removing Event Handlers **
    -----------------------------

    When event handlers are assigned to elements, a connection is formed between
    code that is running the browser and JavaScript code interacting with the
    page. The more of these connections that exist, the slower a page performs.
    One way to handle this issue is through event delegation to limit the number
    of connections that are set up. Another way to manage the issue is to remove
    event handlers when they are no longer needed. Dangling event handlers, those
    that remain in memory after they are necessary, are a major source of memory
    and performance issues in web applications.

    This problem occurs at two specific points during a page's life cycle. The
    first is when an element is removed from the document while it has event
    handlers attached. This can be due to a true DOM manipulation involving
    removeChild() or replaceChild(), but it happens most often when using
    innerHTML to replace a section of the page. Any event handlers assigned to an
    element that was eliminated by the call to innerHTML may not be properly
    garbage collected.

    NOTE: Event delegation also helps solve this problem. If you know that a
          particular part of the page is going to be replaced using innerHTML,
          do not attach event handlers directly to elements within that part.
          Instead, attach event handlers at a higher level that can handle events
          in that area.

    Generally speaking, it's a good idea to remove all event handlers before the
    page is unloaded by using an onunload event handler. This is another area
    where event delegation helps, because it is easier to keep track of the event
    handlers to remove when there are fewer of them. A good way to think about
    this technique is that anything done using an onload event handler must be
    reversed using onunload.


    7. Summary
    ----------

    Events are the primary way that JavaScript is tied to web pages. Most common
    events are defined in the DOM Level 3 Events specifi cation or in HTML5.
    Even though there is a specification for basic events, many browsers have
    gone beyond the specifi cation and implemented proprietary events to give
    developers greater insight into user interactions. Some proprietary events
    are directly related to specifi c devices, such as the mobile Safari
    orientationchange event that is specific to iOS devices.

    There are some memory and performance considerations surrounding events.

        - It's best to limit the number of event handlers on a page, since they
          can take up more memory and make the page feel less responsive to the
          user.

        - Event delegation can be used to limit the number of event handlers by
          taking advantage of event bubbling.

        - It's a good idea to remove all event handlers that were added before
          the page is unloaded.

    It's possible to simulate events in the browser using JavaScript. The DOM
    Level 2 and 3 Events specifications provide for the simulation of all
    events, making it easy to simulate all defined events.  It's also possible
    to simulate keyboard events to a point by using a combination of other
    techniques.

================================================================================


                            CHAP 14: SCRIPTING FORMS
                            ------------------------

    1. Form Basics
    2. Scripting Text Boxes
    3. Scripting Select Boxes
    4. Form Serialization
    5. Rich Text Editing
    6. Summary


    1. Form Basics
    --------------

    ** Submitting Forms **
    ** Resetting Forms **
    ** Form Fields **

    Web forms are represented by the <form> element in HTML and by the
    HTMLFormElement type in JavaScript. The HTMLFormElement type inherits from
    HTMLElement and therefore has all of the same default properties as other
    HTML elements. However, HTMLFormElement also has the following additional
    properties and methods:

        > acceptCharset - The character sets that the server can process;
                          equivalent to the HTML accept-charset attribute.
        > action   - The URL to send the request to; equivalent to the HTML
                     action attribute.
        > elements - An HTMLCollection of all controls in the form.
        > enctype  - The encoding type of the request; equivalent to the HTML
                     enctype attribute.
        > length   - The number of controls in the form.
        > method   - The type of HTTP request to send, typically "get" or "post";
                     equivalent to the HTML method attribute.
        > name     - The name of the form; equivalent to HTML name attribute.
        > reset()  - Resets all form fields to their default values.
        > submit() - Submits the form.
        > target   - The name of the window to use for sending the request and
                     receiving the response; equivalent to the HTML target
                     attribute.

    References to <form> elements can be retrieved in number of different ways.
    The most common way is to treat them as any other elements and assign the id
    attribute, allowing the use of getElementById().

    Ex.

        var form = document.getElementById("form1");

    All forms on the page can also be retrieved from document.forms collection.
    Each form can be accessed in this collection by numeric index and by name,

    Ex.

        var firstForm = document.forms[0];    //get the first form in the page
        var myForm = document.forms["form2"]; //get the form with a name of
                                              //"form2"

    Older browsers, or those with strict backwards compatibility, also add each
    form with a name as a property of the document object. For instance, a form
    named "form2" could be accessed via document.form2. This approach is not
    recommended, because it is error-prone and may be removed from browsers in
    the future.

    Note that forms can have both an id and a name and that these values need
    not be the same.


    ** Submitting Forms **
    ----------------------

    Forms are submitted when a user interacts with a submit button or an image
    button. Submit buttons are defined using either the <input> element or the
    <button> element with a type attribute of "submit", and image buttons are
    defined using the <input> element with a type attribute of "image". All of
    the following, when clicked, will submit a form in which the button resides:

        <!-- generic submit button -->
        <input type="submit" value="Submit Form">

        <!-- custom submit button -->
        <button type="submit">Submit Form</button>

        <!-- image button -->
        <input type="image" src="graphic.gif">

    If any one of these types of buttons is within a form that has a submit
    button, pressing Enter on the keyboard while a form control has focus will
    also submit the form. (The one exception is a textarea, within which Enter
    creates a new line of text.)

    NOTE: forms without submit button will not be submitted when Enter is
          pressed.

    When a form is submitted in this manner, the submit event fires right
    before the request is sent to the server. This gives you the opportunity to
    validate the form data and decide whether to allow the form submission to
    occur. Preventing the event's default behavior cancels the form submission.
    For example, the following prevents a form from being submitted:

        var form = document.getElementById("myForm");
        EventUtil.addHandler(form, "submit", function(event){

            //get event object
            event = EventUtil.getEvent(event);

            //prevent form submission
            EventUtil.preventDefault(event);
        });

    This code uses the EventUtil object from the previous chapter to provide
    cross-browser event handling. The preventDefault() method stops the form
    from being submitted.  Typically, this functionality is used when data in
    the form is invalid and should not be sent to the server.

    It's possible to submit a form programmatically by calling the submit()
    method from JavaScript.  This method can be called at any time to submit a
    form and does not require a submit button to be present in the form to
    function appropriately.

    Ex.

        var form = document.getElementById("myForm");

        //submit the form
        form.submit();

    When a form is submitted via submit(), the submit event does not fire, so be
    sure to do data validation before calling the method.

    One of the biggest issues with form submission is the possibility of
    submitting the form twice.  Users sometimes get impatient when it seems like
    nothing is happening and may click a submit button multiple times. The
    results can be annoying (because the server processes duplicate requests)
    or damaging (if the user is attempting a purchase and ends up placing
    multiple orders). There are essentially two ways to solve this problem:

        - disable the submit button once the form is submitted.
        - use "onsubmit" event handler to cancel any further form submissions.


    ** Resetting Forms **
    ---------------------

    Forms are reset when the user clicks a reset button. Reset buttons are
    created using either the <input> or the <button> element with a type
    attribute of "reset",

    Ex.

        <!-- generic reset button -->
        <input type="reset" value="Reset Form">

        <!-- custom reset button -->
        <button type="reset">Reset Form</button>

    Either of these buttons will reset a form. When a form is reset, all of the
    form fields are set back to the values they had when the page was first
    rendered. If a field was originally blank, it becomes blank again, whereas
    field with a default value reverts to that value.

    When a form is reset by the user clicking a reset button, the reset event
    fires. This event gives you the opportunity to cancel the reset if
    necessary.

    Ex.

        var form = document.getElementById("myForm");
        EventUtil.addHandler(form, "reset", function(event){

            //get event object
            event = EventUtil.getEvent(event);

            //prevent form reset
            EventUtil.preventDefault(event);
        });


    As with form submission, resetting a form can be accomplished via JavaScript
    using the reset() method, as in this example:

    Ex.

        var form = document.getElementById("myForm");

        //reset the form
        form.reset();

    Unlike the submit() method's functionality, reset() fires the reset event
    the same as if a reset button were clicked.

    NOTE: Form resetting is typically a frowned-upon approach to web form
          design. It's often disorienting to the user and, when triggered
          accidentally, can be quite frustrating.  There's almost never need
          to reset a form. It.s often enough to provide a cancel button that
          takes the user back to the previous page rather than explicitly to
          revert all values in the form.


    ** Form Fields **
    -----------------

    Form elements can be accessed in the same ways as any other elements on the
    page using native DOM methods. Additionally, all form elements are parts of
    an elements collection that is a property of each form. The elements
    collection is an ordered list of references to all form fields in the form
    and includes all <input>, <textarea>, <button>, <select>, and <fieldset>
    elements.  Each form field appears in the elements collection in the order
    in which it appears in the markup, indexed by both position and name.

    Ex.

        var form = document.getElementById("form1");

        //get the first field in the form
        var field1 = form.elements[0];

        //get the field named "textbox1"
        var field2 = form"elements["textbox1"];

        //get the number of fields
        var fieldCount = form.elements.length;

    If a name is in use by multiple form controls, as is the case with radio
    buttons, then an HTMLCollection is returned containing all of the elements
    with the name.

    Ex.

        <form method="post" id="myForm">
            <ul>
                <li><input type="radio" name="color" value="red">Red</li>
                <li><input type="radio" name="color" value="green">Green</li>
                <li><input type="radio" name="color" value="blue">Blue</li>
            </ul>
        </form>

    The form in this HTML has three radio controls that have "color" as their
    name, which ties the fields together. When accessing elements["color"], a
    NodeList is returned, containing all three elements; when accessing
    elements[0], however, only the first element is returned.

    Ex.

        var form = document.getElementById("myForm");

        var colorFields = form.elements["color"];
        alert(colorFields.length);                  //3

        var firstColorField = colorFields[0];
        var firstFormField = form.elements[0];
        alert(firstColorField === firstFormField);  //true

    This code shows that the first form field, accessed via form.elements[0],
    is the same as the first element contained in form.elements["color"].

    NOTE: It's possible to access elements as properties of a form as well, such
          as form[0] to get the first form field and form["color"] to get a
          named field. These properties always return the same thing as their
          equivalent in the elements collection. This approach is provided for
          backwards compatibility with older browsers and should be avoided when
          possible in favor of using elements.


    Common Form-Field Properties
    ----------------------------

    With the exception of the <fieldset> element, all form fields share a common
    set of properties.  Since the <input> type represents many form fields, some
    properties are used only with certain field types, whereas others are used
    regardless of the field type.

        > disabled - A Boolean indicating if the field is disabled.
        > form     - A pointer to the form that the field belongs to. This
                     property is read only.
        > name     - The name of the field.
        > readOnly - A Boolean indicating if the field is read only.
        > tabIndex - Indicates the tab order for the fi eld.
        > type     - The type of the field: "checkbox", "radio", and so on.
        > value    - The value of the field that will be submitted to the
                     server.  For file-input fields, this property is read only
                     and simply contains the file's path on the computer.


    2. Scripting Text Boxes
    3. Scripting Select Boxes
    4. Form Serialization
    5. Rich Text Editing
    6. Summary

================================================================================


                      CHAP 17: ERROR HANDLER AND DEBUGGING
                      ------------------------------------

    1. Understanding brower error reporting
    2. Handler errors
    3. Debugging JavaScript code

    1. Understanding brower error reporting
    ---------------------------------------


    2. Handler errors
    -----------------

    ** The try-catch Statement **
    ** Throwing Errors **
    ** Error-handling Strategies **
    ** Identify Where Errors Might Occur **
    ** Distinguishing between Fatal and Nonfatal Errors **
    ** Log Errors to the Server

    ** The try-catch Statement **
    -----------------------------

    << The "finally" Clause >>
    << Error Types >>
    << Usage of try-catch >>

    ECMA-262, third edition, introduced the try-catch statement as a way to
    handle exceptions in JavaScript.

    Ex.

        try {
            // code that may cause an error
        } catch (error) {
            // what to do when error occurs
        }

    Any code that might possibly throw an error should be placed in the try
    portion of the statement, and the code to handle the error is placed in the
    catch portion, as shown in the following example:

    Ex.

        try {
            window.someNonexistentFunction();
        } catch (error) {
            alert('An error happened!');
        }

    If an error occurs at any point in the try portion of the statement, code
    execution immediately exits and resumes in the catch portion. The catch
    portion of the statement receives an object containing information about the
    error that occurred. Unlike other languages, you must define a name for the
    error object even if you don't intend to use it. The exact information
    available on this object varies from browser to browser but contains, at a
    minimum, a message property that holds the error message. ECMA-262 also
    specifies a name property that defines the type of error; this property is
    available in all current browsers. You can, therefore, display the actual
    browser message if necessary, as shown in the following example:

        try {
            window.someNonexistentFunction();
        } catch (error){
            alert(error.message);
        }

    This example uses the 'message' property when displaying an error message to
    the user. The 'message' property is the only one that is guaranteed to be
    there across browsers, even though each browser adds other information.

    << The "finally" Clause >>
    --------------------------

    The optional finally clause of the try-catch statement always runs its code
    no matter what.  If the code in the try portion runs completely, the finally
    clause executes; if there is an error and the catch portion executes, the
    finally portion still executes. There is literally nothing that can be done
    in the try or catch portion of the statement to prevent the code in finally
    from executing, which includes using a return statement.

        function testFinally(){
            try {
                return 2;
            } catch (error){
                return 1;
            } finally {
                return 0;
            }
        }

    This function simply places a return statement in each portion of the
    try-catch statement. It looks like the function should return 2, since that
    is in the try portion and wouldn't cause an error.  However, the presence of
    the finally clause causes that return to be ignored; the function returns
    0 when called no matter what. If the finally clause were removed, the
    function would return 2.

    NOTE: It's very important to understand that any return statements in either
          the try or the catch portion will be ignored if a fi nally clause is
          also included in your code.  Be sure to double-check the intended
          behavior of your code when using finally.

    << Error Types >>
    -----------------

    There are several different types of errors that can occur during the course
    of code execution. Each error type has a corresponding object type that is
    thrown when an error occurs. ECMA-262 defines the following error types:

        - Error
        - EvalError
        - RangeError
        - ReferenceError
        - SyntaxError
        - TypeError
        - URIError

    The Error type is the base type from which all other error types inherit. As
    a result of this, all error types share the same properties (the only
    methods on error objects are the default object methods).  An error of type
    Error is rarely, if ever, thrown by a browser; it is provided mainly for
    developers to throw custom errors.

    << Usage of try-catch >>
    ------------------------

    When an error occurs within a try-catch statement, the browser considers the
    error to have been handled, and so it won't report it using the mechanisms
    discussed earlier in this chapter. This is ideal for web applications with
    users who aren't technically inclined. The try-catch statement allows you to
    implement your own error-handling mechanism for specific error types.

    The try-catch statement is best used where an error might occur that is out
    of your control. For example, if you are using a function that is part of a
    larger JavaScript library, that function may throw errors either
    purposefully or by mistake. Since you can't modify the library's code, it
    would be appropriate to surround the call in a try-catch statement in case
    an error does occur and then handle the error appropriately.

    It's not appropriate to use a try-catch statement if you know an error will
    occur with your code specifically. For example, if a function will fail when
    a string is passed in instead of a number, you should check the data type of
    the argument and act accordingly; there is no need in this case to use a
    try-catch statement.

    ** Throwing Errors **
    ** Error-handling Strategies **
    ** Identify Where Errors Might Occur **
    ** Distinguishing between Fatal and Nonfatal Errors **
    ** Log Errors to the Server


    3. Debugging JavaScript code
    ----------------------------


================================================================================

                                 CHAP 20: JSON
                                 -------------

    1. Understanding JSON syntax
    2. JSON parsing
    3. JSON serialization
    4. Summary

    Douglas Crockford first specified JavaScript Object Notation (JSON) as
    IETF RFC 4627 in 2006 even though it was in use as early as 2001. JSON is a
    strict subset of JavaScript, making use of several patterns found in
    JavaScript to represent structured data.  Crockford put forth JSON as a
    better alternative to XML for accessing structured data in JavaScript, since
    it could be passed directly to eval() and didn't require the creation of a
    DOM.

    The most important thing to understand about JSON is that it is a data
    format, not a programming language. JSON is not a part of JavaScript even
    though they share syntax.  JSON is also not solely used by JavaScript, since
    it is a data format. There are parsers and serializers available in many
    programming languages.


    1. Understanding JSON syntax
    ----------------------------

    ** Syntax **
    ** Simple Values **
    ** Objects **
    ** Arrays **

    ** Syntax **
    ------------

    JSON syntax allows the representation of three types of values:

        - Simple Values > Strings, numbers, Booleans, and null can all be
          represented in JSON using the same syntax as JavaScript. The special
          value undefined is not supported.

        - Objects > The first complex data type, objects represent ordered
          key-value pairs. Each value may be a primitive type or a complex type.

        - Arrays > The second complex data type, arrays represent an ordered
          list of values that are accessible via a numeric index. The values may
          be of any type, including simple values, objects, and even other
          arrays.

    There are no variables, functions, or object instances in JSON. JSON is all
    about representing structured data, and although it shares syntax with
    JavaScript, it should not be confused with JavaScript paradigms.


    ** Simple Values **
    -------------------

    In its simplest form, JSON represents a small number of simple values.

    The big difference between JavaScript strings and JSON strings is that JSON
    strings must use double quotes to be valid (single quotes causes a syntax
    error).

    Boolean values and null are valid exactly as they are as stand-alone JSON.
    In practice, however, JSON is most often used to represent more complex data
    structures of which simple values represent just part of the overall
    information.


    ** Objects **
    -------------

    Objects are represented using a slight modification of object literal
    notation. Object literals in JavaScript look like this:

    Ex.

        var person = {
            name: "Nicholas",
            age: 29
        };

    While this is the standard way that developers create object literals, it's
    the quoted property format that is used in JSON. The following is exactly
    the same as the previous example:

    Ex.

        var person = {
            "name": "Nicholas",
            "age": 29
        };

    The JSON representation of this same object is then:

        {
            "name": "Nicholas",
            "age": 29
        }

    There are a couple of differences from the JavaScript example. First, there
    is no variable declaration (variables don't exist in JSON). Second, there is
    no trailing semicolon (not needed since this isn't a JavaScript statement).
    Once again, the quotes around the property name are required to be valid
    JSON.  The value can be any simple or complex value, allowing you to embed
    objects within objects, such as:

    Ex.

        {
            "name": "Nicholas",
            "age": 29,
            "school": {
                "name": "Merrimack College",
                "location": "North Andover, MA"
            }
        }

    This example embeds school information into the top-level object. Even
    though there are two properties called "name", they are in two different
    objects and so are allowed. You do want to avoid having two properties of
    the same name in the same object.

    Unlike JavaScript, object property names in JSON must always be
    double-quoted.  It's a common mistake to hand-code JSON without these double
    quotes or using single quotes.


    ** Arrays **
    ------------

    The second complex type in JSON is the array. Arrays are represented in JSON
    using array literal notation from JavaScript.

    Ex.

        var values = [25, "hi", true];

    You can represent this same array in JSON using a similar syntax:

    Ex.

        [25, "hi", true]

    Note once again the absence of a variable or a semicolon. Arrays and objects
    can be used together to represent more complex collections of data, such as:

    Ex.

        [
            {
                "title": "Professional JavaScript",
                "authors": [
                    "Nicholas C. Zakas"
                ],
                "edition": 3,
                "year": 2011
            },

            {
                "title": "Professional JavaScript",
                "authors": [
                "Nicholas C. Zakas"
                ],
                "edition": 1,
                "year": 2006
            }
        ]

    This array contains a number of objects representing books. Each object has
    several keys, one of which is "authors", which is another array. Objects and
    arrays are typically top-level parts of a JSON data structure (even though
    this is not required) and can be used to create a large number of data
    structures.

    2. JSON parsing
    ---------------

    JSON's rise to popularity was not necessarily because it used familiar
    syntax. More so, it was because the data could be parsed into a usable
    object in JavaScript. This stood in stark contrast to XML that was parsed
    into a DOM document, making extraction of data into a bit of a chore. For
    example, the JSON code in the previous section contains a list of books,
    and you can easily get the title of the third book via:

        books[2].title

    This assumes that the data structure was stored in a variable named books.
    Compare this to a typical walk through a DOM structure:

        doc.getElementsByTagName("book")[2].getAttribute("title")

    With all of the extra method calls, it's no wonder that JSON became
    incredibly popular with JavaScript developers. After that, JSON went on to
    become the de facto standard for web services.


    3. JSON serialization
    ---------------------

    ** Serialization Options **
    ** The toJSON() Method **
    ** Parsing Options **

    Since JSON is a subset of JavaScript's syntax, eval() could parse,
    interpret, and return the data as JavaScript objects and arrays. ECMAScript
    5 formalized JSON parsing under a native global called JSON.

    The JSON object has two methods: stringify() and parse(). In simple usage,
    these methods serialize JavaScript objects into a JSON string and parse
    JSON into a native JavaScript value, respectively

    Ex.

        var book = {
            title: "Professional JavaScript",
            authors: [
                "Nicholas C. Zakas"
            ],
            edition: 3,
            year: 2011
        };

        var jsonText = JSON.stringify(book);

    This example serializes a JavaScript object into a JSON string using
    JSON.stringify() and stores it in jsonText. By default, JSON.stringify()
    outputs a JSON string without any extra white space or indentation, so the
    value stored in jsonText is:

        {"title":"Professional JavaScript","authors":["Nicholas C.  Zakas"],
         "edition.:3,"year":2011}

    When serializing a JavaScript object, all functions and prototype members
    are intentionally omitted from the result. Additionally, any property whose
    value is undefined is also skipped. You're left with just a representation
    of the instance properties that are one of the JSON data types.

    A JSON string can be passed directly into JSON.parse() and it creates an
    appropriate JavaScript value. For example, you can create an object similar
    to the book object using this code:

        var bookCopy = JSON.parse(jsonText);

    Note that 'book' and 'bookCopy' are each separate objects without any
    relationship to one another even though they do share the same properties.

    An error is thrown if the text passed into JSON.parse() is not valid JSON.


    ** Serialization Options **
    ---------------------------

    The JSON.stringify() method actually accepts two arguments in addition to
    the object to serialize. These arguments allow you to specify alternate ways
    to serialize a JavaScript object. The first argument is a filter, which can
    be either an array or a function, and the second argument is an option for
    indenting the resulting JSON string. When used separately or together, this
    provides some very useful functionality for controlling JSON serialization.

    Filtering Results

    If the argument is an array, then JSON.stringify() will include only object
    properties that are listed in the array. Consider the following:

    Ex.

        var book = {
            "title": "Professional JavaScript",
            "authors": ["Nicholas C. Zakas"],
            edition: 3,
            year: 2011
        };

        var jsonText = JSON.stringify(book, ["title", "edition"]);

    The second argument to JSON.stringify() is an array with two strings:
    "title" and "edition".  These correspond to properties in the object being
    serialized, and so those properties appear in the resulting JSON string:

        {"title":"Professional JavaScript","edition":3}

    When the second argument is a function, the behavior is slightly different.
    The provided function receives two arguments: the property key name and the
    property value. You can look at the key to determine what to do with the
    property. The key is always a string but might be an empty string if a value
    isn't part of a key-value pair.

    In order to change the serialization of the object, return the value that
    should be included for that key. Keep in mind that returning undefined will
    result in the property being omitted from the result.

    Ex.
        var book = {

            "title": "Professional JavaScript",
            "authors": ["Nicholas C. Zakas"],
            edition: 3,
            year: 2011
        };

        var jsonText = JSON.stringify(book, function(key, value){
            switch(key){
                case "authors":
                    return value.join(",")

                case "year":
                   return 5000;

                case "edition":
                    return undefined;

                default:
                    return value;
            }
        });

    The function filters based on the key. The "authors" key is translated from
    an array to a string, the "year" key is set to 5000, and the "edition" key
    is removed altogether by returning undefined.  It's important to provide a
    default behavior that returns the passed-in value so that all other values
    are passed through to the result. The first call to this function actually
    has key equal to an empty string and the value set to the book object. The
    resulting JSON string is:

        {"title":"Professional JavaScript","authors":"Nicholas C.
            Zakas","year":5000}

    Keep in mind that filters apply to all objects contained in the object to
    be serialized, so an array of multiple objects with these properties will
    result in every object including only the "title" and "edition" properties.

    String Indentation

    The third argument of JSON.stringify() controls indentation and white space.
    When this argument is a number, it represents the number of spaces to indent
    each level. For example, to indent each level by four spaces,

        var book = {

            "title": "Professional JavaScript",
            "authors": ["Nicholas C. Zakas"],
            edition: 3,
            year: 2011
        };

        var jsonText = JSON.stringify(book, null, 4);

    The string stored in jsonText is:

        {
            "title": "Professional JavaScript",
            "authors": [ "Nicholas C. Zakas" ],
            "edition": 3,
            "year": 2011
        }

    You may have noticed that JSON.stringify() also inserts new lines into the
    JSON string for easier reading. This happens for all valid indentation
    argument values.  (Indentation without new lines isn't very useful.) The
    maximum numeric indentation value is 10; passing in a value larger than 10
    automatically sets the value to 10.

    If the indentation argument is a string instead of a number, then the string
    is used as the indentation character for the JSON string instead of a space.
    Using a string, you can set the indentation character to be a tab or
    something completely arbitrary like two dashes:

        var jsonText = JSON.stringify(book, null, " - -");

    The jsonText value then becomes:

        {
        --"title": "Professional JavaScript",
        --"authors": [ "Nicholas C. Zakas" ],
        --"edition": 3,
        --"year": 2011
        }

    There is a ten-character limit on the indentation string to use. If a string
    longer than ten characters is used, then it is truncated to the first ten
    characters.

    ** The toJSON() Method **
    -------------------------

    Sometimes objects need custom JSON serialization above and beyond what
    JSON.stringify() can do. In those cases, you can add a toJSON() method to
    the object and have it return the proper JSON representation for itself. In
    fact, the native Date object has a toJSON() method that automatically
    converts JavaScript Date objects into an ISO 8601 date string.

    Ex.

        var book = {

            "title": "Professional JavaScript",
            "authors": ["Nicholas C. Zakas"],
            edition: 3,
            year: 2011

            toJSON: function(){
                return this.title;
            }
        };

        var jsonText = JSON.stringify(book);

    This code defines a toJSON() method on the book object that simply returns
    the title of the book.  Similar to the Date object, this object is
    serialized to a simple string instead of an object. You can return any
    serialization value from toJSON(), and it will work appropriately. Returning
    undefined causes the value to become null if the object is embedded in
    another object or else is just undefined if the object is top-level.

    The toJSON() method can be used in addition to the filter function, and so
    it's important to understand the order in which the various parts of a
    serialization process take place. When an object is passed into
    JSON.stringify(), the following steps are taken:

        1. Call the toJSON() method if it's available to retrieve the actual
           value. Use the default serialization otherwise.
        2. If the second argument is provided, apply the filter. The value that
           is passed into a filter function will be the value returned from
           step 1.
        3. Each value from step 2 is serialized appropriately.
        4. If the third argument is provided, format appropriately.

    It's important to understand this order when deciding whether to create a
    toJSON() method or to use a filter function or to do both.

    ** Parsing Options **
    ---------------------

    The JSON.parse() method also accepts an additional argument, which is a
    function that is called on each key-value pair. The function is called a
    reviver function to distinguish it from the replacer (filter) function that
    JSON.stringify() accepts, even though the format is exactly the same: the
    function receives two arguments, the key and the value, and needs to return
    a value.

    If the reviver function returns undefined, then the key is removed from the
    result; if it returns any other value, that value is inserted into the
    result.  A very common use of the reviver function is to turn date strings
    into Date objects.


    4. Summary
    ----------

    JSON is a lightweight data format designed to easily represent complex data
    structures. The format uses a subset of JavaScript syntax to represent
    objects, arrays, strings, numbers, Booleans, and null. Even though XML can
    handle the same job, JSON is less verbose and has better support in
    JavaScript.

    ECMAScript 5 defines a native JSON object that is used for serialization of
    objects into JSON format and for parsing JSON data into JavaScript objects.
    The JSON.stringify() and JSON.parse() methods are used for these two
    operations, respectively. Both methods have a number of options that allow
    you to change the default behavior to filter or otherwise modify the
    process.

================================================================================


                                 CHAP 21: AJAX
                                 -------------

    1. Using XMLHttpRequest object
    2. Working with XMLHttpRequest events
    3. Cross-domain Ajax restrictions

    AJAX, short for Asynchronous JavaScript+XML consisted of making server
    requests for additional data without unloading the web page, resulting in a
    better user experience.

    The key technology pushing Ajax forward was the XMLHttpRequest (XHR) object,
    first invented by Microsoft. Prior to the introduction of XHR, Ajax-style
    communication had to be accomplished through a number of hacks, mostly using
    hidden frames or iframes. XHR introduced a streamlined interface for making
    server requests and evaluating the responses. This allowed for asynchronous
    retrieval of additional information from the server, meaning that a user
    click didn't have to refresh the page to retrieve more data. Instead, an XHR
    object could be used to retrieve the data and then the data could be
    inserted into the page using the DOM. And despite the mention of XML in the
    name, Ajax communication is format-agnostic; the technique is about
    retrieving data from the server without refreshing a page, not necessarily
    about XML.

    The XHR object brought native browser communication capabilities to
    developers, reducing the amount of work necessary to achieve the result.


    1. Using XMLHttpRequest object
    ------------------------------

    ** XHR Usage **
    ** HTTP Headers **
    ** GET Requests **
    ** POST Requests **

    ** XHR Usage **
    ---------------

    XHR object that can be created using the XMLHttpRequest constructor as
    follows:

    Ex.

        var xhr = new XMLHttpRequest();

    To begin using an XHR object, you will first call the method open(), which
    accepts three arguments: the type of request to be sent ('get', 'post', and
    so on), the URL for the request, and a Boolean value indicating if the
    request should be sent asynchronously.  Here's an example:

        xhr.open('get', 'example.php', false);

    This line opens a synchronous GET request for example.php. There are a
    couple of things to note about this code. First, the URL is relative to the
    page on which the code is called, although an absolute path can be given as
    well. Second, the call to open() does not actually send the request; it
    simply prepares a request to be sent.

        xhr.open('get', 'example.txt', false);
        xhr.send(null);

    The send() method accepts a single argument, which is data to be sent as the
    body of the request.  If no body data needs to be sent, you must pass in
    null, because this argument is required for some browsers. Once send() is
    called, the request is dispatched to the server.

    NOTE: GET or POST?  GET is simpler and faster than POST, and can be used in
          most cases.

          However, always use POST requests when:

          - A cached file is not an option (update a file or database on the
            server)
          - Sending a large amount of data to the server (POST has no size
            limitations)
          - Sending user input (which can contain unknown characters), POST is
            more robust and secure than GET

    Since this request is synchronous, the JavaScript code will wait for the
    response to return before continuing execution. When a response is received,
    the XHR object properties are filled with data.  The relevant properties are
    as follows:

        - responseText > The text that was returned as the body of the response.
        - responseXML  > Contains an XML DOM document with the response data if the
                         response has a content type of 'text/xml' or
                         'application/xml'.

        - status     > The HTTP status of the response.
        - statusText > The description of the HTTP status.

    When a response is received, the first step is to check the status property
    to ensure that the response was returned successfully. Generally, HTTP
    status codes in the 200s are considered successful and some content will be
    available in responseText and possibly in responseXML if the content type is
    correct. In addition, the status code of 304 indicates that a resource
    hasn't been modified and is being served from the browser's cache, which
    also means a response is available.  To ensure that a proper response was
    received, you should check for all of these statuses,

    Ex.

        xhr.open("get", "example.txt", false);
        xhr.send(null);

        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
            alert(xhr.responseText);
        } else {
            alert("Request was unsuccessful: " + xhr.status);
        }

    It's recommended to always check the status property to determine the best
    course of action and to avoid using statusText for this purpose, because the
    latter has proven to be unreliable across browsers. The responseText
    property is always filled with the body of the response, regardless of the
    content type, whereas responseXML will be null for non-XML data.

    Although it's possible to make synchronous requests such as this one, most
    of the time it's better to make asynchronous requests that allow JavaScript
    code execution to continue without waiting for the response. The XHR object
    has a readyState property that indicates what phase of the request/response
    cycle is currently active. The possible values are as follows:

        0 - Uninitialized. The open() method hasn't been called yet.
        1 - Open. The open() method has been called but send() has not been
            called.
        2 - Sent. The send() method has been called but no response has been
            received.
        3 - Receiving. Some response data has been retrieved.
        4 - Complete. All of the response data has been retrieved and is
            available.

    Whenever the readyState changes from one value to another, the
    readystatechange event is fired. You can use this opportunity to check the
    value of readyState.  Generally speaking, the only readyState of interest
    is 4, which indicates that all of the data is ready.  The onreadystatechange
    event handler should be assigned prior to calling open() for cross-browser
    compatibility. Consider the following example:

    Ex.

        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                if ((xhr.status >=200 && xhr.status <300) || xhr.status == 304){
                    alert(xhr.responseText);
                } else {
                    alert("Request was unsuccessful: " + xhr.status);
                }
            }
        };

        xhr.open('get', 'example.txt', true);
        xhr.send(null);

    Note that this code uses the DOM Level 0 style of attaching an event handler
    to the XHR object, because not all browsers support the DOM Level 2 style of
    event attachment.  Unlike other event handlers, no event object is passed
    into the onreadystatechange event handler. Instead you must use the XHR
    object itself to determine what to do next.

    ** HTTP Headers **
    ------------------

    Every HTTP request and response sends along with it a group of header
    information that may or may not be of interest to the developer. The XHR
    object exposes both types of headers - those on the request and those on the
    response - through several methods.

    By default, the following headers are sent when an XHR request is sent:

        - Accept > The content types that the browser can handle.
        - Accept-Charset > The character sets that the browser can display.
        - Accept-Encoding > The compression encodings handled by the browser.
        - Accept-Language > The languages the browser is running in.
        - Connection > The type of connection the browser is making with the
                       server.
        - Cookie  > Any cookies set on the page.
        - Host    > The domain of the page making the request.
        - Referer > The URI of the page making the request. Note that this
                    header is spelled incorrectly in the HTTP specification and
                    so must be spelled incorrectly for compatibility purposes.
                    (The correct spelling of this word is 'referrer'.)
        - User-Agent > The browser.s user-agent string.

    You can set additional request headers by using the setRequestHeader()
    method.  This method accepts two arguments: the name of the header and the
    value of the header. For request headers to be sent, setRequestHeader() must
    be called after open() but before send(), as in the following example:

    Ex.

        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                if ((xhr.status >=200 && xhr.status <300) || xhr.status == 304){
                    alert(xhr.responseText);
                } else {
                    alert("Request was unsuccessful: " + xhr.status);
                }
            }
        };

        xhr.open('get', 'example.txt', true);
        xhr.setRequestHeader('MyHeader', 'MyValue');
        xhr.send(null);

    The server can read these custom request headers to determine an appropriate
    course of action. It's advisable to always use custom header names rather
    than those the browser normally sends, because using the default ones may
    affect the server response. Some browsers will allow overwriting default
    headers, but others will not.

    You can retrieve the response headers from an XHR object by using the
    getResponseHeader() method and passing in the name of the header to
    retrieve. It's also possible to retrieve all headers as a long string by
    using the getAllResponseHeaders() method.

        var myHeader   = xhr.getResponseHeader('MyHeader');
        var allHeaders = xhr.getAllResponseHeaders();

    Headers can be used to pass additional, structured data from the server to
    the browser. The getAllResponseHeaders() method typically returns:

        Date: Sun, 14 Nov 2004 18:04:03 GMT
        Server: Apache/1.3.29 (Unix)
        Vary: Accept
        X-Powered-By: PHP/4.3.8
        Connection: close
        Content-Type: text/html; charset=iso-8859-1

    This output allows you to parse the response headers to find all of the
    header names that were sent rather than check for the existence of each one
    individually.

    ** GET Requests **
    ------------------

    The most common type of request to execute is a GET, which is typically made
    when the server is being queried for some sort of information. If necessary,
    query-string arguments can be appended to the end of the URL to pass
    information to the server. For XHR, this query string must be present and
    encoded correctly on the URL that is passed into the open() method.

    One of the most frequent errors made with GET requests is to have an
    improperly formatted query string. Each query-string name and value must be
    encoded using encodeURIComponent() before being attached to the URL, and all
    of the name-value pairs must be separated by an ampersand, as

    Ex.

        xhr.open('get', "example.php?name1=value1&name2=value2", true);

    The following function helps to add query-string arguments to the end of an
    existing URL:

        function addURLParam(url, name, value) {
            url += (url.indexOf("?") == -1 ? "?" : "&");
            url += encodeURIComponent(name) + "=" + encodeURIComponent(value);
            return url;
        }

        var url = 'example.php';

        //add the arguments
        url = addURLParam(url, "name", "Nicholas");
        url = addURLParam(url, "book", "Professional JavaScript");

        //initiate request
        xhr.open("get", url, false);

    Using the addURLParam() function here ensures that the query string is
    properly formed for use with the XHR object.


    ** POST Requests **
    -------------------

    POST is typically used to send data to the server that should save data.
    Each POST request is expected to have data submitted as the body of the
    request, whereas GET requests traditionally do not. The body of a POST
    request can contain a very large amount of data, and that data can be in any
    format. You can initiate a POST request by specifying post as the first
    argument to the open() method.

        xhr.open("post", "example.php", true);

    The second part is to pass some data to the send() method. Since XHR was
    originally designed to work primarily with XML, you can pass in an XML DOM
    document that will be serialized and submitted as the request body. You can
    also pass in any string to send to the server.  By default, a POST request
    does not appear the same to the server as a web-form submission. Server
    logic will need to read the raw post data to retrieve your data. You can,
    however, mimic a form submission using XHR. The first step is to set the
    Content-Type header to application/x-www-form-urlencoded, which is the
    content type set when a form is submitted. The second step is to create a
    string in the appropriate format.  Post data is sent in the same
    format as a query string. If a form already on the page should be serialized
    and sent to the server via XHR,

    Ex.

        function submitData(){
            ...
            ...
        }

    NOTE: POST requests have more overhead associated with them than do GET
          requests.  In terms of performance, GET requests can be up to two
          times faster than POST requests sending the same amount of data.


    2. Working with XMLHttpRequest events
    -------------------------------------

    The Progress Events specification is a W3C Working Draft defining events
    for client-server communication. These events were first targeted at XHR
    explicitly but have now also made their way into other similar APIs. There
    are six progress events:

        - loadstart > Fires when the first byte of the response has been
                      received.
        - progress  > Fires repeatedly as a response is being received.
        - error     > Fires when there was an error attempting the request.
        - abort > Fires when the connection was terminated by calling abort().
        - load  > Fires when the response has been fully received.
        - loadend   > Fires when the communication is complete and after firing
                      error, abort, or load.

    Each request begins with the loadstart event being fired; followed by one
    or more progress events; then one of error, abort, or load; finally ending
    with loadend.

    3. Cross-domain Ajax restrictions
    ---------------------------------

    One of the major limitations of Ajax communication via XHR is the
    cross-origin security policy. By default, XHR objects can access resources
    only on the domain from which the containing web page originates. This
    security feature prevents some malicious behavior. However, the need for
    legitimate cross-origin access was great enough for solutions to begin
    appearing in browsers.


================================================================================


                                    APPENDIX
                                    --------


    OBJECT-ORIENTED (Class). Rather than class definitions, JavaScript has
    constructor functions and the "new" operator.  A constructor function can
    specify an object's initial properties and values when it is instantiated.
    Any JavaScript function can be used as a constructor. Use the "new" operator
    with a constructor function to create a new instance.

    The new operator changes a function's context, as well as the behavior of
    the return statement. In practice, using "new" and constructors is fairly
    similar to languages with native class implementations.

    When a constructor function is called with the "new" keyword, the context
    switches from global (window) to a new and empty context specific to that
    instance. So, the "this" keyword refers to the current instance. Although it
    might sound complicated, in practice, you can treat it like native class
    implementations in other languages.

    JavaScript is a prototype-based language and rather than make distinctions
    between classes and instances, it has the notions of a prototypical object:
    an object used as a template from which to get the initial properties for a
    new object. Any object can be associated as a prototype of another object,
    sharing its properties. In practice, you can look at this as a form of
    inheritance

    When you fetch a property on an object, JavaScript will search the local
    object for the property. If it isn't found, JavaScript will start searching
    the object's prototype and continue up the prototype tree, eventually reaching
    Object.prototype. If the property is found, its value is returned;
    otherwise, 'undefined' will be returned.  In other words, if you start
    adding properties to Array.prototype, they'll be reflected across every
    JavaScript array.

    To subclass a class and inherit its properties, you need to first define a
    constructor function. Then, you need to assign a new instance of the parent
    class as the prototype for your constructor function.

    Ex.

        var Animal = function() {};

        Animal.prototype.breath = function() {
            alert('breath');
        };

        var Dog = function() {};

        // Dog inherits from Animal
        Dog.prototype = new Animal;

        Dog.prototype.wag = function() {
            alert('wag tail');
        }

        var dog = new Dog;
        dog.wag();
        dog.breath();



    ---

    Functions can be roughly divided into those that are called for their side
    effects, and those that are called for their return value. (Though it's
    definitely also possible to have both side effects and return a value.

    A pure function is a specific kind of value-producing function that not only
    has no side effects, but also doesn't rely on side effects from other
    code-for example, it doesn't read global variables that are occasionally
    changed by other code. A pure function has the pleasant property that, when
    called with the same arguments, it always produces the same value (and
    doesn't do anything else). This makes it easy to reason about. A call to
    such a function can be mentally substituted by its result, without changing
    the meaning of the code. When you are not sure that a pure function is
    working correctly, you can test it by simply calling it and know that if it
    works in that context, it will work in any context. Non-pure functions might
    return different values based on all kinds of factors and have side effects
    that might be hard to test and think about.

    ---

    CALLBACKS are a simpler concept. A callback is basically where a function
              accepts another function as a parameter. At some point during
    execution the called function will execute the function passed as a
    parameter, this is a callback. Quite often the callback actually happens as
    an asynchronous event, in which case the called function may return without
    having executed the callback, that may happen later

    NOTE: asynchronous events are those occurring independently of the main
          program flow. Asynchronous actions are actions executed in a
          non-blocking scheme, allowing the main program flow to continue
          processing.

    ---

    CLOSURES AND CALLBACKS

    Quite often the reason that closures get created (either incidentally,
    accidentally or deliberately) is the need to create a callback.


    ---

    Stack vs Heap Pros and Cons
    ---------------------------

    What is the stack? It's a special region of your computer's memory that
    stores temporary variables created by each function. The stack is a "FILO"
    (first in, last out) data structure, that is managed and optimized by the
    CPU quite closely. Every time a function declares a new variable, it is
    "pushed" onto the stack. Then every time a function exits, all of the
    variables pushed onto the stack by that function, are freed (that is to say,
    they are deleted). Once a stack variable is freed, that region of memory
    becomes available for other stack variables.

    A key to understanding the stack is the notion that when a function exits,
    all of its variables are popped off of the stack (and hence lost forever).
    Thus stack variables are local in nature.

    The heap is a region of your computer's memory that is not managed
    automatically for you, and is not as tightly managed by the CPU. It is
    a more free-floating region of memory (and is larger).

    Unlike the stack, the heap does not have size restrictions on variable
    size. Heap memory is slightly slower to be read from and written to,
    because one has to use pointers to access memory on the heap.

    Unlike the stack, variables created on the heap are accessible by any
    function, anywhere in your program. Heap variables are essentially global
    in scope.

    ** Stack **

        - very fast access
        - don't have to explicitly de-allocate variables
        - space is managed efficiently by CPU, memory will not become fragmented
        - local variables only
        - limit on stack size (OS-dependent)
        - variables cannot be resized

    ** Heap **

        - variables can be accessed globally
        - no limit on memory size
        - (relatively) slower access
        - no guaranteed efficient use of space, memory may become fragmented over time
          as blocks of memory are allocated, then freed
        - you must manage memory (you're in charge of allocating and freeing
          variables)
        - variables can be resized using realloc()



================================================================================


                                     TOOLS
                                     -----


 1. Basic JavaScript/Developement Tools


 1. Basic JavaScript/Developement Tools
 --------------------------------------

    Install tools using the following commands:

        yum -y install httpd nodejs npm

